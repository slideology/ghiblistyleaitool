# AIå›¾ç‰‡ç”Ÿæˆé¡¹ç›®æ¨¡æ¿ç»“æ„

## ğŸ“ æ¨èçš„é¡¹ç›®ç›®å½•ç»“æ„

```
my-ai-image-app/
â”œâ”€â”€ ğŸ“ frontend/                    # å‰ç«¯ä»£ç 
â”‚   â”œâ”€â”€ ğŸ“ src/
â”‚   â”‚   â”œâ”€â”€ ğŸ“ components/          # ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ common/          # é€šç”¨ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ FileUpload.tsx  # æ–‡ä»¶ä¸Šä¼ ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ LoadingSpinner.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ErrorMessage.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ forms/           # è¡¨å•ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ParameterForm.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ StyleSelector.tsx
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ results/         # ç»“æœå±•ç¤ºç»„ä»¶
â”‚   â”‚   â”‚       â”œâ”€â”€ ImagePreview.tsx
â”‚   â”‚   â”‚       â””â”€â”€ TaskProgress.tsx
â”‚   â”‚   â”œâ”€â”€ ğŸ“ hooks/               # è‡ªå®šä¹‰Hook
â”‚   â”‚   â”‚   â”œâ”€â”€ useFileUpload.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ useTaskPolling.ts
â”‚   â”‚   â”‚   â””â”€â”€ useImageProcessor.ts
â”‚   â”‚   â”œâ”€â”€ ğŸ“ services/            # APIæœåŠ¡
â”‚   â”‚   â”‚   â”œâ”€â”€ api.ts              # APIå®¢æˆ·ç«¯
â”‚   â”‚   â”‚   â”œâ”€â”€ storage.ts          # å­˜å‚¨æœåŠ¡
â”‚   â”‚   â”‚   â””â”€â”€ tasks.ts            # ä»»åŠ¡ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ ğŸ“ types/               # ç±»å‹å®šä¹‰
â”‚   â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ task.ts
â”‚   â”‚   â”‚   â””â”€â”€ user.ts
â”‚   â”‚   â”œâ”€â”€ ğŸ“ utils/               # å·¥å…·å‡½æ•°
â”‚   â”‚   â”‚   â”œâ”€â”€ validation.ts       # éªŒè¯å‡½æ•°
â”‚   â”‚   â”‚   â”œâ”€â”€ formatting.ts       # æ ¼å¼åŒ–å‡½æ•°
â”‚   â”‚   â”‚   â””â”€â”€ constants.ts        # å¸¸é‡
â”‚   â”‚   â”œâ”€â”€ App.tsx                 # ä¸»åº”ç”¨ç»„ä»¶
â”‚   â”‚   â””â”€â”€ main.tsx                # å…¥å£æ–‡ä»¶
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ vite.config.ts              # Viteé…ç½®
â”‚   â””â”€â”€ tsconfig.json               # TypeScripté…ç½®
â”œâ”€â”€ ğŸ“ backend/                     # åç«¯ä»£ç 
â”‚   â”œâ”€â”€ ğŸ“ src/
â”‚   â”‚   â”œâ”€â”€ ğŸ“ controllers/         # æ§åˆ¶å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ tasks.ts            # ä»»åŠ¡æ§åˆ¶å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ upload.ts           # ä¸Šä¼ æ§åˆ¶å™¨
â”‚   â”‚   â”‚   â””â”€â”€ webhook.ts          # Webhookæ§åˆ¶å™¨
â”‚   â”‚   â”œâ”€â”€ ğŸ“ services/            # ä¸šåŠ¡æœåŠ¡
â”‚   â”‚   â”‚   â”œâ”€â”€ storage.ts          # å­˜å‚¨æœåŠ¡
â”‚   â”‚   â”‚   â”œâ”€â”€ ai-client.ts        # AIå®¢æˆ·ç«¯
â”‚   â”‚   â”‚   â”œâ”€â”€ task-manager.ts     # ä»»åŠ¡ç®¡ç†
â”‚   â”‚   â”‚   â””â”€â”€ prompt-builder.ts   # æç¤ºè¯æ„å»º
â”‚   â”‚   â”œâ”€â”€ ğŸ“ models/              # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”‚   â”œâ”€â”€ task.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ user.ts
â”‚   â”‚   â”‚   â””â”€â”€ credit.ts
â”‚   â”‚   â”œâ”€â”€ ğŸ“ database/            # æ•°æ®åº“
â”‚   â”‚   â”‚   â”œâ”€â”€ schema.sql          # æ•°æ®åº“ç»“æ„
â”‚   â”‚   â”‚   â”œâ”€â”€ migrations/         # æ•°æ®åº“è¿ç§»
â”‚   â”‚   â”‚   â””â”€â”€ connection.ts       # æ•°æ®åº“è¿æ¥
â”‚   â”‚   â”œâ”€â”€ ğŸ“ middleware/          # ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.ts             # è®¤è¯ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ validation.ts       # éªŒè¯ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â””â”€â”€ error-handler.ts    # é”™è¯¯å¤„ç†
â”‚   â”‚   â”œâ”€â”€ ğŸ“ utils/               # å·¥å…·å‡½æ•°
â”‚   â”‚   â”‚   â”œâ”€â”€ crypto.ts           # åŠ å¯†å·¥å…·
â”‚   â”‚   â”‚   â”œâ”€â”€ file-utils.ts       # æ–‡ä»¶å·¥å…·
â”‚   â”‚   â”‚   â””â”€â”€ logger.ts           # æ—¥å¿—å·¥å…·
â”‚   â”‚   â”œâ”€â”€ ğŸ“ config/              # é…ç½®
â”‚   â”‚   â”‚   â”œâ”€â”€ app.ts              # åº”ç”¨é…ç½®
â”‚   â”‚   â”‚   â”œâ”€â”€ database.ts         # æ•°æ®åº“é…ç½®
â”‚   â”‚   â”‚   â””â”€â”€ ai-providers.ts     # AIæœåŠ¡é…ç½®
â”‚   â”‚   â””â”€â”€ index.ts                # å…¥å£æ–‡ä»¶
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â””â”€â”€ wrangler.toml               # Cloudflare Workersé…ç½®
â”œâ”€â”€ ğŸ“ shared/                      # å…±äº«ä»£ç 
â”‚   â”œâ”€â”€ ğŸ“ types/                   # å…±äº«ç±»å‹
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”œâ”€â”€ task.ts
â”‚   â”‚   â””â”€â”€ config.ts
â”‚   â””â”€â”€ ğŸ“ constants/               # å…±äº«å¸¸é‡
â”‚       â”œâ”€â”€ file-types.ts
â”‚       â””â”€â”€ status-codes.ts
â”œâ”€â”€ ğŸ“ docs/                        # æ–‡æ¡£
â”‚   â”œâ”€â”€ API.md                      # APIæ–‡æ¡£
â”‚   â”œâ”€â”€ DEPLOYMENT.md               # éƒ¨ç½²æ–‡æ¡£
â”‚   â””â”€â”€ DEVELOPMENT.md              # å¼€å‘æ–‡æ¡£
â”œâ”€â”€ ğŸ“ scripts/                     # è„šæœ¬
â”‚   â”œâ”€â”€ setup.sh                   # ç¯å¢ƒè®¾ç½®è„šæœ¬
â”‚   â”œâ”€â”€ deploy.sh                   # éƒ¨ç½²è„šæœ¬
â”‚   â””â”€â”€ db-migrate.ts               # æ•°æ®åº“è¿ç§»è„šæœ¬
â”œâ”€â”€ .env.example                    # ç¯å¢ƒå˜é‡ç¤ºä¾‹
â”œâ”€â”€ .gitignore                      # Gitå¿½ç•¥æ–‡ä»¶
â”œâ”€â”€ README.md                       # é¡¹ç›®è¯´æ˜
â”œâ”€â”€ package.json                    # æ ¹package.json
â””â”€â”€ docker-compose.yml              # Dockeré…ç½®ï¼ˆå¯é€‰ï¼‰
```

## ğŸ“‹ æ ¸å¿ƒæ–‡ä»¶æ¨¡æ¿

### 1. å‰ç«¯æ–‡ä»¶ä¸Šä¼ ç»„ä»¶

**æ–‡ä»¶**: `frontend/src/components/common/FileUpload.tsx`

```typescript
import React, { useState, useCallback } from 'react';

interface FileUploadProps {
  onFileSelect: (files: File[]) => void;
  acceptedTypes?: string[];
  maxFileSize?: number; // MB
  maxFiles?: number;
  disabled?: boolean;
}

export const FileUpload: React.FC<FileUploadProps> = ({
  onFileSelect,
  acceptedTypes = ['image/jpeg', 'image/png', 'image/webp'],
  maxFileSize = 10,
  maxFiles = 1,
  disabled = false
}) => {
  const [dragActive, setDragActive] = useState(false);
  const [errors, setErrors] = useState<string[]>([]);

  const validateFiles = useCallback((files: File[]): File[] => {
    const newErrors: string[] = [];
    const validFiles: File[] = [];

    if (files.length > maxFiles) {
      newErrors.push(`æœ€å¤šåªèƒ½é€‰æ‹© ${maxFiles} ä¸ªæ–‡ä»¶`);
      files = files.slice(0, maxFiles);
    }

    files.forEach(file => {
      // æ£€æŸ¥æ–‡ä»¶ç±»å‹
      if (!acceptedTypes.includes(file.type)) {
        newErrors.push(`ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${file.name}`);
        return;
      }

      // æ£€æŸ¥æ–‡ä»¶å¤§å°
      if (file.size > maxFileSize * 1024 * 1024) {
        newErrors.push(`æ–‡ä»¶å¤ªå¤§: ${file.name} (æœ€å¤§ ${maxFileSize}MB)`);
        return;
      }

      validFiles.push(file);
    });

    setErrors(newErrors);
    return validFiles;
  }, [acceptedTypes, maxFileSize, maxFiles]);

  const handleFiles = useCallback((files: FileList | null) => {
    if (!files) return;
    
    const fileArray = Array.from(files);
    const validFiles = validateFiles(fileArray);
    
    if (validFiles.length > 0) {
      onFileSelect(validFiles);
    }
  }, [validateFiles, onFileSelect]);

  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (disabled) return;
    
    handleFiles(e.dataTransfer.files);
  }, [handleFiles, disabled]);

  const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    handleFiles(e.target.files);
  }, [handleFiles]);

  return (
    <div className="file-upload">
      <div
        className={`upload-area ${
          dragActive ? 'drag-active' : ''
        } ${disabled ? 'disabled' : ''}`}
        onDragEnter={handleDrag}
        onDragLeave={handleDrag}
        onDragOver={handleDrag}
        onDrop={handleDrop}
      >
        <input
          type="file"
          multiple={maxFiles > 1}
          accept={acceptedTypes.join(',')}
          onChange={handleChange}
          disabled={disabled}
          className="file-input"
        />
        <div className="upload-content">
          <div className="upload-icon">ğŸ“</div>
          <p>æ‹–æ‹½æ–‡ä»¶åˆ°è¿™é‡Œæˆ–ç‚¹å‡»é€‰æ‹©</p>
          <p className="upload-hint">
            æ”¯æŒ {acceptedTypes.map(type => type.split('/')[1]).join(', ')} æ ¼å¼ï¼Œ
            æœ€å¤§ {maxFileSize}MB
          </p>
        </div>
      </div>
      
      {errors.length > 0 && (
        <div className="error-list">
          {errors.map((error, index) => (
            <p key={index} className="error-message">{error}</p>
          ))}
        </div>
      )}
    </div>
  );
};
```

### 2. ä»»åŠ¡è½®è¯¢Hook

**æ–‡ä»¶**: `frontend/src/hooks/useTaskPolling.ts`

```typescript
import { useState, useEffect, useCallback } from 'react';
import { Task, TaskStatus } from '../types/task';
import { taskService } from '../services/tasks';

interface UseTaskPollingOptions {
  intervalMs?: number;
  maxAttempts?: number;
  onComplete?: (task: Task) => void;
  onError?: (error: Error) => void;
}

export const useTaskPolling = (
  initialTasks: Task[],
  options: UseTaskPollingOptions = {}
) => {
  const {
    intervalMs = 2000,
    maxAttempts = 150, // 5åˆ†é’Ÿ
    onComplete,
    onError
  } = options;

  const [tasks, setTasks] = useState<Task[]>(initialTasks);
  const [attempts, setAttempts] = useState(0);
  const [isPolling, setIsPolling] = useState(false);

  const isTaskCompleted = useCallback((task: Task): boolean => {
    return task.status === 'completed' || task.status === 'failed';
  }, []);

  const updateTask = useCallback(async (task: Task): Promise<Task> => {
    try {
      const updatedTask = await taskService.getTaskStatus(task.id);
      
      if (updatedTask.status === 'completed' && onComplete) {
        onComplete(updatedTask);
      }
      
      return updatedTask;
    } catch (error) {
      if (onError) {
        onError(error as Error);
      }
      return task;
    }
  }, [onComplete, onError]);

  const startPolling = useCallback(() => {
    setIsPolling(true);
    setAttempts(0);
  }, []);

  const stopPolling = useCallback(() => {
    setIsPolling(false);
  }, []);

  useEffect(() => {
    if (!isPolling || tasks.length === 0) return;
    
    const allCompleted = tasks.every(isTaskCompleted);
    if (allCompleted) {
      setIsPolling(false);
      return;
    }

    if (attempts >= maxAttempts) {
      setIsPolling(false);
      console.warn('è¾¾åˆ°æœ€å¤§è½®è¯¢æ¬¡æ•°');
      return;
    }

    const pollTasks = async () => {
      try {
        const updatedTasks = await Promise.all(
          tasks.map(async (task) => {
            if (isTaskCompleted(task)) return task;
            return await updateTask(task);
          })
        );

        setTasks(updatedTasks);
        setAttempts(prev => prev + 1);
      } catch (error) {
        console.error('è½®è¯¢é”™è¯¯:', error);
      }
    };

    const timer = setTimeout(pollTasks, intervalMs);
    return () => clearTimeout(timer);
  }, [tasks, isPolling, attempts, maxAttempts, intervalMs, isTaskCompleted, updateTask]);

  return {
    tasks,
    setTasks,
    isPolling,
    attempts,
    startPolling,
    stopPolling,
    allCompleted: tasks.every(isTaskCompleted)
  };
};
```

### 3. åç«¯å­˜å‚¨æœåŠ¡

**æ–‡ä»¶**: `backend/src/services/storage.ts`

```typescript
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

export interface StorageConfig {
  provider: 'r2' | 's3';
  bucket: string;
  region?: string;
  accessKeyId: string;
  secretAccessKey: string;
  endpoint?: string;
  cdnUrl?: string;
}

export interface UploadResult {
  key: string;
  url: string;
  size: number;
  contentType: string;
}

export class StorageService {
  private client: S3Client;
  private config: StorageConfig;

  constructor(config: StorageConfig) {
    this.config = config;
    this.client = new S3Client({
      region: config.region || 'auto',
      credentials: {
        accessKeyId: config.accessKeyId,
        secretAccessKey: config.secretAccessKey,
      },
      endpoint: config.endpoint,
    });
  }

  /**
   * ä¸Šä¼ æ–‡ä»¶åˆ°å­˜å‚¨æœåŠ¡
   */
  async uploadFile(
    file: File | Blob,
    key: string,
    contentType?: string
  ): Promise<UploadResult> {
    const command = new PutObjectCommand({
      Bucket: this.config.bucket,
      Key: key,
      Body: file,
      ContentType: contentType || 'application/octet-stream',
    });

    await this.client.send(command);

    return {
      key,
      url: this.getPublicUrl(key),
      size: file.size,
      contentType: contentType || 'application/octet-stream',
    };
  }

  /**
   * ä»URLä¸‹è½½æ–‡ä»¶å¹¶ä¸Šä¼ åˆ°å­˜å‚¨
   */
  async downloadAndUpload(
    sourceUrl: string,
    destinationKey: string
  ): Promise<UploadResult> {
    const response = await fetch(sourceUrl);
    if (!response.ok) {
      throw new Error(`ä¸‹è½½å¤±è´¥: ${response.statusText}`);
    }

    const blob = await response.blob();
    return this.uploadFile(blob, destinationKey, blob.type);
  }

  /**
   * ç”Ÿæˆå…¬å…±è®¿é—®URL
   */
  getPublicUrl(key: string): string {
    if (this.config.cdnUrl) {
      return `${this.config.cdnUrl}/${key}`;
    }
    
    if (this.config.provider === 'r2') {
      return `https://${this.config.bucket}.r2.cloudflarestorage.com/${key}`;
    }
    
    return `https://${this.config.bucket}.s3.${this.config.region}.amazonaws.com/${key}`;
  }

  /**
   * ç”Ÿæˆé¢„ç­¾åURLï¼ˆç”¨äºå®‰å…¨ä¸Šä¼ ï¼‰
   */
  async getPresignedUploadUrl(
    key: string,
    contentType: string,
    expiresIn: number = 3600
  ): Promise<string> {
    const command = new PutObjectCommand({
      Bucket: this.config.bucket,
      Key: key,
      ContentType: contentType,
    });

    return getSignedUrl(this.client, command, { expiresIn });
  }

  /**
   * ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
   */
  generateUniqueKey(originalName: string, folder: string = ''): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    const extension = originalName.split('.').pop();
    const baseName = originalName.split('.').slice(0, -1).join('.');
    
    const fileName = `${timestamp}_${random}_${baseName}.${extension}`;
    return folder ? `${folder}/${fileName}` : fileName;
  }
}
```

### 4. AIä»»åŠ¡ç®¡ç†æœåŠ¡

**æ–‡ä»¶**: `backend/src/services/task-manager.ts`

```typescript
import { StorageService } from './storage';
import { AIClient } from './ai-client';
import { PromptBuilder } from './prompt-builder';
import { DatabaseService } from './database';

export interface CreateTaskOptions {
  userId: string;
  inputFiles: File[];
  parameters: Record<string, any>;
  taskType: string;
  credits?: number;
}

export interface Task {
  id: string;
  userId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  taskType: string;
  inputFiles: string[];
  parameters: Record<string, any>;
  prompt?: string;
  aiTaskId?: string;
  resultUrls?: string[];
  error?: string;
  createdAt: Date;
  completedAt?: Date;
}

export class TaskManager {
  constructor(
    private storage: StorageService,
    private aiClient: AIClient,
    private promptBuilder: PromptBuilder,
    private database: DatabaseService
  ) {}

  /**
   * åˆ›å»ºæ–°çš„AIä»»åŠ¡
   */
  async createTask(options: CreateTaskOptions): Promise<Task> {
    const { userId, inputFiles, parameters, taskType, credits } = options;

    // 1. éªŒè¯ç”¨æˆ·ç§¯åˆ†
    if (credits && credits > 0) {
      await this.validateAndConsumeCredits(userId, credits);
    }

    // 2. ä¸Šä¼ è¾“å…¥æ–‡ä»¶
    const uploadedFiles = await Promise.all(
      inputFiles.map(async (file) => {
        const key = this.storage.generateUniqueKey(file.name, 'input');
        const result = await this.storage.uploadFile(file, key, file.type);
        return result.url;
      })
    );

    // 3. ç”Ÿæˆæç¤ºè¯
    const prompt = this.promptBuilder.buildPrompt(taskType, parameters);

    // 4. åˆ›å»ºæ•°æ®åº“è®°å½•
    const task: Task = {
      id: this.generateTaskId(),
      userId,
      status: 'pending',
      taskType,
      inputFiles: uploadedFiles,
      parameters,
      prompt,
      createdAt: new Date(),
    };

    await this.database.createTask(task);

    // 5. æäº¤åˆ°AIæœåŠ¡
    try {
      const aiResult = await this.aiClient.createTask({
        inputUrls: uploadedFiles,
        prompt,
        parameters,
      });

      // æ›´æ–°ä»»åŠ¡çŠ¶æ€
      task.aiTaskId = aiResult.taskId;
      task.status = 'processing';
      await this.database.updateTask(task.id, {
        aiTaskId: aiResult.taskId,
        status: 'processing',
      });

      return task;
    } catch (error) {
      // å¤„ç†å¤±è´¥ï¼Œé€€è¿˜ç§¯åˆ†
      if (credits && credits > 0) {
        await this.refundCredits(userId, credits);
      }

      task.status = 'failed';
      task.error = (error as Error).message;
      await this.database.updateTask(task.id, {
        status: 'failed',
        error: task.error,
      });

      throw error;
    }
  }

  /**
   * æ›´æ–°ä»»åŠ¡çŠ¶æ€
   */
  async updateTaskStatus(taskId: string): Promise<Task> {
    const task = await this.database.getTask(taskId);
    if (!task || !task.aiTaskId) {
      throw new Error('ä»»åŠ¡ä¸å­˜åœ¨æˆ–æ— æ•ˆ');
    }

    // æŸ¥è¯¢AIæœåŠ¡çŠ¶æ€
    const aiStatus = await this.aiClient.getTaskStatus(task.aiTaskId);

    switch (aiStatus.status) {
      case 'processing':
        return task; // çŠ¶æ€æ— å˜åŒ–

      case 'completed':
        // ä¸‹è½½ç»“æœæ–‡ä»¶
        const resultUrls = await Promise.all(
          aiStatus.resultUrls.map(async (url, index) => {
            const key = this.storage.generateUniqueKey(
              `result_${index}.png`,
              'output'
            );
            const result = await this.storage.downloadAndUpload(url, key);
            return result.url;
          })
        );

        // æ›´æ–°ä»»åŠ¡çŠ¶æ€
        const updatedTask = {
          ...task,
          status: 'completed' as const,
          resultUrls,
          completedAt: new Date(),
        };

        await this.database.updateTask(taskId, {
          status: 'completed',
          resultUrls,
          completedAt: updatedTask.completedAt,
        });

        return updatedTask;

      case 'failed':
        // ä»»åŠ¡å¤±è´¥ï¼Œé€€è¿˜ç§¯åˆ†
        if (task.parameters.credits) {
          await this.refundCredits(task.userId, task.parameters.credits);
        }

        const failedTask = {
          ...task,
          status: 'failed' as const,
          error: aiStatus.error,
          completedAt: new Date(),
        };

        await this.database.updateTask(taskId, {
          status: 'failed',
          error: aiStatus.error,
          completedAt: failedTask.completedAt,
        });

        return failedTask;

      default:
        return task;
    }
  }

  /**
   * è·å–ç”¨æˆ·ä»»åŠ¡åˆ—è¡¨
   */
  async getUserTasks(
    userId: string,
    limit: number = 20,
    offset: number = 0
  ): Promise<Task[]> {
    return this.database.getUserTasks(userId, limit, offset);
  }

  /**
   * éªŒè¯å¹¶æ¶ˆè´¹ç§¯åˆ†
   */
  private async validateAndConsumeCredits(
    userId: string,
    credits: number
  ): Promise<void> {
    const userCredits = await this.database.getUserCredits(userId);
    if (userCredits < credits) {
      throw new Error('ç§¯åˆ†ä¸è¶³');
    }

    await this.database.consumeCredits(userId, credits);
  }

  /**
   * é€€è¿˜ç§¯åˆ†
   */
  private async refundCredits(userId: string, credits: number): Promise<void> {
    await this.database.addCredits(userId, credits, 'ä»»åŠ¡å¤±è´¥é€€æ¬¾');
  }

  /**
   * ç”Ÿæˆä»»åŠ¡ID
   */
  private generateTaskId(): string {
    return `task_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
}
```

### 5. ç¯å¢ƒé…ç½®æ–‡ä»¶

**æ–‡ä»¶**: `.env.example`

```bash
# åº”ç”¨åŸºç¡€é…ç½®
APP_NAME="æˆ‘çš„AIå›¾ç‰‡å¤„ç†å™¨"
APP_VERSION="1.0.0"
NODE_ENV="development"
PORT=3000
DOMAIN="http://localhost:3000"

# æ•°æ®åº“é…ç½®
DATABASE_URL="./database.sqlite"
# æˆ–è€…ä½¿ç”¨ PostgreSQL
# DATABASE_URL="postgresql://username:password@localhost:5432/myapp"

# å­˜å‚¨é…ç½® (é€‰æ‹©ä¸€ä¸ª)
# Cloudflare R2
STORAGE_PROVIDER="r2"
R2_BUCKET_NAME="my-ai-images"
R2_ACCESS_KEY_ID="your-r2-access-key"
R2_SECRET_ACCESS_KEY="your-r2-secret-key"
R2_ENDPOINT="https://your-account-id.r2.cloudflarestorage.com"
CDN_URL="https://your-cdn-domain.com"

# æˆ–è€… AWS S3
# STORAGE_PROVIDER="s3"
# S3_BUCKET_NAME="my-ai-images"
# S3_ACCESS_KEY_ID="your-s3-access-key"
# S3_SECRET_ACCESS_KEY="your-s3-secret-key"
# S3_REGION="us-east-1"

# AIæœåŠ¡é…ç½®
# OpenAI
OPENAI_API_KEY="sk-your-openai-api-key"
OPENAI_BASE_URL="https://api.openai.com/v1"

# Stability AI
STABILITY_API_KEY="sk-your-stability-api-key"
STABILITY_BASE_URL="https://api.stability.ai/v1"

# é»˜è®¤AIæä¾›å•†
DEFAULT_AI_PROVIDER="openai"

# Webhooké…ç½®
WEBHOOK_SECRET="your-webhook-secret-key"

# ä¸šåŠ¡é…ç½®
NEW_USER_CREDITS=10
TASK_COST_CREDITS=1
MAX_FILE_SIZE_MB=100
MAX_FILES_PER_TASK=5
MAX_TASKS_PER_USER=100
MAX_TASKS_PER_DAY=50

# å®‰å…¨é…ç½®
JWT_SECRET="your-jwt-secret-key"
ENCRYPTION_KEY="your-encryption-key"

# ç›‘æ§é…ç½®
LOG_LEVEL="info"
ENABLE_METRICS="true"
ENABLE_TRACING="false"

# é‚®ä»¶é…ç½®ï¼ˆå¯é€‰ï¼‰
SMTP_HOST="smtp.gmail.com"
SMTP_PORT=587
SMTP_USER="your-email@gmail.com"
SMTP_PASS="your-email-password"

# æ”¯ä»˜é…ç½®ï¼ˆå¯é€‰ï¼‰
STRIPE_PUBLIC_KEY="pk_test_your-stripe-public-key"
STRIPE_SECRET_KEY="sk_test_your-stripe-secret-key"
STRIPE_WEBHOOK_SECRET="whsec_your-stripe-webhook-secret"
```

### 6. æ•°æ®åº“åˆå§‹åŒ–è„šæœ¬

**æ–‡ä»¶**: `backend/src/database/schema.sql`

```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  username TEXT UNIQUE,
  password_hash TEXT,
  avatar_url TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·ç§¯åˆ†è¡¨
CREATE TABLE IF NOT EXISTS user_credits (
  user_id TEXT PRIMARY KEY,
  credits INTEGER DEFAULT 0,
  total_earned INTEGER DEFAULT 0,
  total_spent INTEGER DEFAULT 0,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- AIä»»åŠ¡è¡¨
CREATE TABLE IF NOT EXISTS ai_tasks (
  id TEXT PRIMARY KEY,
  task_no TEXT UNIQUE NOT NULL,
  user_id TEXT NOT NULL,
  task_type TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending',
  ai_provider TEXT NOT NULL,
  ai_model TEXT,
  ai_task_id TEXT,
  
  -- è¾“å…¥æ•°æ®
  input_files TEXT, -- JSON array
  input_parameters TEXT, -- JSON object
  prompt TEXT,
  
  -- è¾“å‡ºæ•°æ®
  result_urls TEXT, -- JSON array
  result_metadata TEXT, -- JSON object
  
  -- é”™è¯¯ä¿¡æ¯
  error_message TEXT,
  retry_count INTEGER DEFAULT 0,
  
  -- æ—¶é—´æˆ³
  estimated_completion_at DATETIME,
  started_at DATETIME,
  completed_at DATETIME,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- ç§¯åˆ†äº¤æ˜“è®°å½•è¡¨
CREATE TABLE IF NOT EXISTS credit_transactions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  task_id TEXT,
  transaction_type TEXT NOT NULL, -- 'earn', 'spend', 'refund'
  amount INTEGER NOT NULL,
  balance_before INTEGER NOT NULL,
  balance_after INTEGER NOT NULL,
  description TEXT,
  metadata TEXT, -- JSON object
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (task_id) REFERENCES ai_tasks(id) ON DELETE SET NULL
);

-- ç³»ç»Ÿé…ç½®è¡¨
CREATE TABLE IF NOT EXISTS system_config (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  description TEXT,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_ai_tasks_user_id ON ai_tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_ai_tasks_status ON ai_tasks(status);
CREATE INDEX IF NOT EXISTS idx_ai_tasks_created_at ON ai_tasks(created_at);
CREATE INDEX IF NOT EXISTS idx_ai_tasks_task_type ON ai_tasks(task_type);

CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_id ON credit_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_credit_transactions_created_at ON credit_transactions(created_at);

-- æ’å…¥é»˜è®¤é…ç½®
INSERT OR IGNORE INTO system_config (key, value, description) VALUES
('new_user_credits', '10', 'æ–°ç”¨æˆ·æ³¨å†Œèµ é€ç§¯åˆ†'),
('task_cost_credits', '1', 'æ¯ä¸ªä»»åŠ¡æ¶ˆè€—ç§¯åˆ†'),
('max_file_size_mb', '100', 'æœ€å¤§æ–‡ä»¶å¤§å°(MB)'),
('max_files_per_task', '5', 'æ¯ä¸ªä»»åŠ¡æœ€å¤§æ–‡ä»¶æ•°'),
('max_tasks_per_day', '50', 'æ¯æ—¥æœ€å¤§ä»»åŠ¡æ•°');
```

### 7. éƒ¨ç½²é…ç½®

**æ–‡ä»¶**: `docker-compose.yml`

```yaml
version: '3.8'

services:
  # å‰ç«¯æœåŠ¡
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - VITE_API_BASE_URL=http://backend:8000
    depends_on:
      - backend
    volumes:
      - ./frontend:/app
      - /app/node_modules

  # åç«¯æœåŠ¡
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - NODE_ENV=development
      - DATABASE_URL=postgresql://postgres:password@postgres:5432/aiapp
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
    volumes:
      - ./backend:/app
      - /app/node_modules
      - ./uploads:/app/uploads

  # æ•°æ®åº“
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=aiapp
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backend/src/database/schema.sql:/docker-entrypoint-initdb.d/schema.sql

  # Redisç¼“å­˜
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # Nginxåå‘ä»£ç†
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend

volumes:
  postgres_data:
  redis_data:
```

## ğŸš€ å¿«é€Ÿå¼€å§‹è„šæœ¬

**æ–‡ä»¶**: `scripts/setup.sh`

```bash
#!/bin/bash

# AIå›¾ç‰‡ç”Ÿæˆé¡¹ç›®å¿«é€Ÿè®¾ç½®è„šæœ¬

echo "ğŸš€ å¼€å§‹è®¾ç½®AIå›¾ç‰‡ç”Ÿæˆé¡¹ç›®..."

# æ£€æŸ¥Node.js
if ! command -v node &> /dev/null; then
    echo "âŒ è¯·å…ˆå®‰è£…Node.js"
    exit 1
fi

# æ£€æŸ¥pnpm
if ! command -v pnpm &> /dev/null; then
    echo "ğŸ“¦ å®‰è£…pnpm..."
    npm install -g pnpm
fi

# å¤åˆ¶ç¯å¢ƒå˜é‡æ–‡ä»¶
if [ ! -f .env ]; then
    echo "ğŸ“ åˆ›å»ºç¯å¢ƒå˜é‡æ–‡ä»¶..."
    cp .env.example .env
    echo "âš ï¸  è¯·ç¼–è¾‘ .env æ–‡ä»¶é…ç½®ä½ çš„APIå¯†é’¥"
fi

# å®‰è£…å‰ç«¯ä¾èµ–
echo "ğŸ“¦ å®‰è£…å‰ç«¯ä¾èµ–..."
cd frontend
pnpm install
cd ..

# å®‰è£…åç«¯ä¾èµ–
echo "ğŸ“¦ å®‰è£…åç«¯ä¾èµ–..."
cd backend
pnpm install
cd ..

# åˆå§‹åŒ–æ•°æ®åº“
echo "ğŸ—„ï¸ åˆå§‹åŒ–æ•°æ®åº“..."
node scripts/db-migrate.js

# åˆ›å»ºå¿…è¦ç›®å½•
echo "ğŸ“ åˆ›å»ºç›®å½•ç»“æ„..."
mkdir -p uploads/input
mkdir -p uploads/output
mkdir -p uploads/temp
mkdir -p logs

echo "âœ… é¡¹ç›®è®¾ç½®å®Œæˆï¼"
echo ""
echo "ä¸‹ä¸€æ­¥ï¼š"
echo "1. ç¼–è¾‘ .env æ–‡ä»¶é…ç½®APIå¯†é’¥"
echo "2. è¿è¡Œ 'pnpm dev' å¯åŠ¨å¼€å‘æœåŠ¡å™¨"
echo "3. è®¿é—® http://localhost:3000"
echo ""
echo "ğŸ“š æŸ¥çœ‹æ–‡æ¡£ï¼š"
echo "- README.md - é¡¹ç›®ä»‹ç»"
echo "- docs/API.md - APIæ–‡æ¡£"
echo "- docs/DEVELOPMENT.md - å¼€å‘æŒ‡å—"
```

## ğŸ“š ä½¿ç”¨è¯´æ˜

### 1. åˆ›å»ºæ–°é¡¹ç›®

```bash
# 1. åˆ›å»ºé¡¹ç›®ç›®å½•
mkdir my-ai-image-app
cd my-ai-image-app

# 2. å¤åˆ¶æ¨¡æ¿ç»“æ„
# æŒ‰ç…§ä¸Šé¢çš„ç›®å½•ç»“æ„åˆ›å»ºæ–‡ä»¶å’Œæ–‡ä»¶å¤¹

# 3. è¿è¡Œè®¾ç½®è„šæœ¬
chmod +x scripts/setup.sh
./scripts/setup.sh

# 4. é…ç½®ç¯å¢ƒå˜é‡
vim .env

# 5. å¯åŠ¨å¼€å‘æœåŠ¡å™¨
pnpm dev
```

### 2. è‡ªå®šä¹‰é…ç½®

æ ¹æ®ä½ çš„å…·ä½“éœ€æ±‚ä¿®æ”¹ä»¥ä¸‹æ–‡ä»¶ï¼š

- **æç¤ºè¯æ¨¡æ¿**: `backend/src/services/prompt-builder.ts`
- **AIæœåŠ¡é€‚é…å™¨**: `backend/src/services/ai-client.ts`
- **å‰ç«¯ç•Œé¢**: `frontend/src/components/`
- **ä¸šåŠ¡é€»è¾‘**: `backend/src/controllers/`

### 3. éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ

```bash
# ä½¿ç”¨Dockeréƒ¨ç½²
docker-compose up -d

# æˆ–è€…ä½¿ç”¨Cloudflare Workers
cd backend
npx wrangler deploy

# éƒ¨ç½²å‰ç«¯åˆ°Vercel/Netlify
cd frontend
npm run build
```

è¿™ä¸ªæ¨¡æ¿æä¾›äº†å®Œæ•´çš„é¡¹ç›®ç»“æ„å’Œæ ¸å¿ƒä»£ç ï¼Œä½ å¯ä»¥æ ¹æ®å…·ä½“éœ€æ±‚è¿›è¡Œå®šåˆ¶å’Œæ‰©å±•ã€‚