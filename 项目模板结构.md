# AI图片生成项目模板结构

## 📁 推荐的项目目录结构

```
my-ai-image-app/
├── 📁 frontend/                    # 前端代码
│   ├── 📁 src/
│   │   ├── 📁 components/          # 组件
│   │   │   ├── 📁 common/          # 通用组件
│   │   │   │   ├── FileUpload.tsx  # 文件上传组件
│   │   │   │   ├── LoadingSpinner.tsx
│   │   │   │   └── ErrorMessage.tsx
│   │   │   ├── 📁 forms/           # 表单组件
│   │   │   │   ├── ParameterForm.tsx
│   │   │   │   └── StyleSelector.tsx
│   │   │   └── 📁 results/         # 结果展示组件
│   │   │       ├── ImagePreview.tsx
│   │   │       └── TaskProgress.tsx
│   │   ├── 📁 hooks/               # 自定义Hook
│   │   │   ├── useFileUpload.ts
│   │   │   ├── useTaskPolling.ts
│   │   │   └── useImageProcessor.ts
│   │   ├── 📁 services/            # API服务
│   │   │   ├── api.ts              # API客户端
│   │   │   ├── storage.ts          # 存储服务
│   │   │   └── tasks.ts            # 任务管理
│   │   ├── 📁 types/               # 类型定义
│   │   │   ├── api.ts
│   │   │   ├── task.ts
│   │   │   └── user.ts
│   │   ├── 📁 utils/               # 工具函数
│   │   │   ├── validation.ts       # 验证函数
│   │   │   ├── formatting.ts       # 格式化函数
│   │   │   └── constants.ts        # 常量
│   │   ├── App.tsx                 # 主应用组件
│   │   └── main.tsx                # 入口文件
│   ├── package.json
│   ├── vite.config.ts              # Vite配置
│   └── tsconfig.json               # TypeScript配置
├── 📁 backend/                     # 后端代码
│   ├── 📁 src/
│   │   ├── 📁 controllers/         # 控制器
│   │   │   ├── tasks.ts            # 任务控制器
│   │   │   ├── upload.ts           # 上传控制器
│   │   │   └── webhook.ts          # Webhook控制器
│   │   ├── 📁 services/            # 业务服务
│   │   │   ├── storage.ts          # 存储服务
│   │   │   ├── ai-client.ts        # AI客户端
│   │   │   ├── task-manager.ts     # 任务管理
│   │   │   └── prompt-builder.ts   # 提示词构建
│   │   ├── 📁 models/              # 数据模型
│   │   │   ├── task.ts
│   │   │   ├── user.ts
│   │   │   └── credit.ts
│   │   ├── 📁 database/            # 数据库
│   │   │   ├── schema.sql          # 数据库结构
│   │   │   ├── migrations/         # 数据库迁移
│   │   │   └── connection.ts       # 数据库连接
│   │   ├── 📁 middleware/          # 中间件
│   │   │   ├── auth.ts             # 认证中间件
│   │   │   ├── validation.ts       # 验证中间件
│   │   │   └── error-handler.ts    # 错误处理
│   │   ├── 📁 utils/               # 工具函数
│   │   │   ├── crypto.ts           # 加密工具
│   │   │   ├── file-utils.ts       # 文件工具
│   │   │   └── logger.ts           # 日志工具
│   │   ├── 📁 config/              # 配置
│   │   │   ├── app.ts              # 应用配置
│   │   │   ├── database.ts         # 数据库配置
│   │   │   └── ai-providers.ts     # AI服务配置
│   │   └── index.ts                # 入口文件
│   ├── package.json
│   ├── tsconfig.json
│   └── wrangler.toml               # Cloudflare Workers配置
├── 📁 shared/                      # 共享代码
│   ├── 📁 types/                   # 共享类型
│   │   ├── api.ts
│   │   ├── task.ts
│   │   └── config.ts
│   └── 📁 constants/               # 共享常量
│       ├── file-types.ts
│       └── status-codes.ts
├── 📁 docs/                        # 文档
│   ├── API.md                      # API文档
│   ├── DEPLOYMENT.md               # 部署文档
│   └── DEVELOPMENT.md              # 开发文档
├── 📁 scripts/                     # 脚本
│   ├── setup.sh                   # 环境设置脚本
│   ├── deploy.sh                   # 部署脚本
│   └── db-migrate.ts               # 数据库迁移脚本
├── .env.example                    # 环境变量示例
├── .gitignore                      # Git忽略文件
├── README.md                       # 项目说明
├── package.json                    # 根package.json
└── docker-compose.yml              # Docker配置（可选）
```

## 📋 核心文件模板

### 1. 前端文件上传组件

**文件**: `frontend/src/components/common/FileUpload.tsx`

```typescript
import React, { useState, useCallback } from 'react';

interface FileUploadProps {
  onFileSelect: (files: File[]) => void;
  acceptedTypes?: string[];
  maxFileSize?: number; // MB
  maxFiles?: number;
  disabled?: boolean;
}

export const FileUpload: React.FC<FileUploadProps> = ({
  onFileSelect,
  acceptedTypes = ['image/jpeg', 'image/png', 'image/webp'],
  maxFileSize = 10,
  maxFiles = 1,
  disabled = false
}) => {
  const [dragActive, setDragActive] = useState(false);
  const [errors, setErrors] = useState<string[]>([]);

  const validateFiles = useCallback((files: File[]): File[] => {
    const newErrors: string[] = [];
    const validFiles: File[] = [];

    if (files.length > maxFiles) {
      newErrors.push(`最多只能选择 ${maxFiles} 个文件`);
      files = files.slice(0, maxFiles);
    }

    files.forEach(file => {
      // 检查文件类型
      if (!acceptedTypes.includes(file.type)) {
        newErrors.push(`不支持的文件类型: ${file.name}`);
        return;
      }

      // 检查文件大小
      if (file.size > maxFileSize * 1024 * 1024) {
        newErrors.push(`文件太大: ${file.name} (最大 ${maxFileSize}MB)`);
        return;
      }

      validFiles.push(file);
    });

    setErrors(newErrors);
    return validFiles;
  }, [acceptedTypes, maxFileSize, maxFiles]);

  const handleFiles = useCallback((files: FileList | null) => {
    if (!files) return;
    
    const fileArray = Array.from(files);
    const validFiles = validateFiles(fileArray);
    
    if (validFiles.length > 0) {
      onFileSelect(validFiles);
    }
  }, [validateFiles, onFileSelect]);

  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (disabled) return;
    
    handleFiles(e.dataTransfer.files);
  }, [handleFiles, disabled]);

  const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    handleFiles(e.target.files);
  }, [handleFiles]);

  return (
    <div className="file-upload">
      <div
        className={`upload-area ${
          dragActive ? 'drag-active' : ''
        } ${disabled ? 'disabled' : ''}`}
        onDragEnter={handleDrag}
        onDragLeave={handleDrag}
        onDragOver={handleDrag}
        onDrop={handleDrop}
      >
        <input
          type="file"
          multiple={maxFiles > 1}
          accept={acceptedTypes.join(',')}
          onChange={handleChange}
          disabled={disabled}
          className="file-input"
        />
        <div className="upload-content">
          <div className="upload-icon">📁</div>
          <p>拖拽文件到这里或点击选择</p>
          <p className="upload-hint">
            支持 {acceptedTypes.map(type => type.split('/')[1]).join(', ')} 格式，
            最大 {maxFileSize}MB
          </p>
        </div>
      </div>
      
      {errors.length > 0 && (
        <div className="error-list">
          {errors.map((error, index) => (
            <p key={index} className="error-message">{error}</p>
          ))}
        </div>
      )}
    </div>
  );
};
```

### 2. 任务轮询Hook

**文件**: `frontend/src/hooks/useTaskPolling.ts`

```typescript
import { useState, useEffect, useCallback } from 'react';
import { Task, TaskStatus } from '../types/task';
import { taskService } from '../services/tasks';

interface UseTaskPollingOptions {
  intervalMs?: number;
  maxAttempts?: number;
  onComplete?: (task: Task) => void;
  onError?: (error: Error) => void;
}

export const useTaskPolling = (
  initialTasks: Task[],
  options: UseTaskPollingOptions = {}
) => {
  const {
    intervalMs = 2000,
    maxAttempts = 150, // 5分钟
    onComplete,
    onError
  } = options;

  const [tasks, setTasks] = useState<Task[]>(initialTasks);
  const [attempts, setAttempts] = useState(0);
  const [isPolling, setIsPolling] = useState(false);

  const isTaskCompleted = useCallback((task: Task): boolean => {
    return task.status === 'completed' || task.status === 'failed';
  }, []);

  const updateTask = useCallback(async (task: Task): Promise<Task> => {
    try {
      const updatedTask = await taskService.getTaskStatus(task.id);
      
      if (updatedTask.status === 'completed' && onComplete) {
        onComplete(updatedTask);
      }
      
      return updatedTask;
    } catch (error) {
      if (onError) {
        onError(error as Error);
      }
      return task;
    }
  }, [onComplete, onError]);

  const startPolling = useCallback(() => {
    setIsPolling(true);
    setAttempts(0);
  }, []);

  const stopPolling = useCallback(() => {
    setIsPolling(false);
  }, []);

  useEffect(() => {
    if (!isPolling || tasks.length === 0) return;
    
    const allCompleted = tasks.every(isTaskCompleted);
    if (allCompleted) {
      setIsPolling(false);
      return;
    }

    if (attempts >= maxAttempts) {
      setIsPolling(false);
      console.warn('达到最大轮询次数');
      return;
    }

    const pollTasks = async () => {
      try {
        const updatedTasks = await Promise.all(
          tasks.map(async (task) => {
            if (isTaskCompleted(task)) return task;
            return await updateTask(task);
          })
        );

        setTasks(updatedTasks);
        setAttempts(prev => prev + 1);
      } catch (error) {
        console.error('轮询错误:', error);
      }
    };

    const timer = setTimeout(pollTasks, intervalMs);
    return () => clearTimeout(timer);
  }, [tasks, isPolling, attempts, maxAttempts, intervalMs, isTaskCompleted, updateTask]);

  return {
    tasks,
    setTasks,
    isPolling,
    attempts,
    startPolling,
    stopPolling,
    allCompleted: tasks.every(isTaskCompleted)
  };
};
```

### 3. 后端存储服务

**文件**: `backend/src/services/storage.ts`

```typescript
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

export interface StorageConfig {
  provider: 'r2' | 's3';
  bucket: string;
  region?: string;
  accessKeyId: string;
  secretAccessKey: string;
  endpoint?: string;
  cdnUrl?: string;
}

export interface UploadResult {
  key: string;
  url: string;
  size: number;
  contentType: string;
}

export class StorageService {
  private client: S3Client;
  private config: StorageConfig;

  constructor(config: StorageConfig) {
    this.config = config;
    this.client = new S3Client({
      region: config.region || 'auto',
      credentials: {
        accessKeyId: config.accessKeyId,
        secretAccessKey: config.secretAccessKey,
      },
      endpoint: config.endpoint,
    });
  }

  /**
   * 上传文件到存储服务
   */
  async uploadFile(
    file: File | Blob,
    key: string,
    contentType?: string
  ): Promise<UploadResult> {
    const command = new PutObjectCommand({
      Bucket: this.config.bucket,
      Key: key,
      Body: file,
      ContentType: contentType || 'application/octet-stream',
    });

    await this.client.send(command);

    return {
      key,
      url: this.getPublicUrl(key),
      size: file.size,
      contentType: contentType || 'application/octet-stream',
    };
  }

  /**
   * 从URL下载文件并上传到存储
   */
  async downloadAndUpload(
    sourceUrl: string,
    destinationKey: string
  ): Promise<UploadResult> {
    const response = await fetch(sourceUrl);
    if (!response.ok) {
      throw new Error(`下载失败: ${response.statusText}`);
    }

    const blob = await response.blob();
    return this.uploadFile(blob, destinationKey, blob.type);
  }

  /**
   * 生成公共访问URL
   */
  getPublicUrl(key: string): string {
    if (this.config.cdnUrl) {
      return `${this.config.cdnUrl}/${key}`;
    }
    
    if (this.config.provider === 'r2') {
      return `https://${this.config.bucket}.r2.cloudflarestorage.com/${key}`;
    }
    
    return `https://${this.config.bucket}.s3.${this.config.region}.amazonaws.com/${key}`;
  }

  /**
   * 生成预签名URL（用于安全上传）
   */
  async getPresignedUploadUrl(
    key: string,
    contentType: string,
    expiresIn: number = 3600
  ): Promise<string> {
    const command = new PutObjectCommand({
      Bucket: this.config.bucket,
      Key: key,
      ContentType: contentType,
    });

    return getSignedUrl(this.client, command, { expiresIn });
  }

  /**
   * 生成唯一文件名
   */
  generateUniqueKey(originalName: string, folder: string = ''): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    const extension = originalName.split('.').pop();
    const baseName = originalName.split('.').slice(0, -1).join('.');
    
    const fileName = `${timestamp}_${random}_${baseName}.${extension}`;
    return folder ? `${folder}/${fileName}` : fileName;
  }
}
```

### 4. AI任务管理服务

**文件**: `backend/src/services/task-manager.ts`

```typescript
import { StorageService } from './storage';
import { AIClient } from './ai-client';
import { PromptBuilder } from './prompt-builder';
import { DatabaseService } from './database';

export interface CreateTaskOptions {
  userId: string;
  inputFiles: File[];
  parameters: Record<string, any>;
  taskType: string;
  credits?: number;
}

export interface Task {
  id: string;
  userId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  taskType: string;
  inputFiles: string[];
  parameters: Record<string, any>;
  prompt?: string;
  aiTaskId?: string;
  resultUrls?: string[];
  error?: string;
  createdAt: Date;
  completedAt?: Date;
}

export class TaskManager {
  constructor(
    private storage: StorageService,
    private aiClient: AIClient,
    private promptBuilder: PromptBuilder,
    private database: DatabaseService
  ) {}

  /**
   * 创建新的AI任务
   */
  async createTask(options: CreateTaskOptions): Promise<Task> {
    const { userId, inputFiles, parameters, taskType, credits } = options;

    // 1. 验证用户积分
    if (credits && credits > 0) {
      await this.validateAndConsumeCredits(userId, credits);
    }

    // 2. 上传输入文件
    const uploadedFiles = await Promise.all(
      inputFiles.map(async (file) => {
        const key = this.storage.generateUniqueKey(file.name, 'input');
        const result = await this.storage.uploadFile(file, key, file.type);
        return result.url;
      })
    );

    // 3. 生成提示词
    const prompt = this.promptBuilder.buildPrompt(taskType, parameters);

    // 4. 创建数据库记录
    const task: Task = {
      id: this.generateTaskId(),
      userId,
      status: 'pending',
      taskType,
      inputFiles: uploadedFiles,
      parameters,
      prompt,
      createdAt: new Date(),
    };

    await this.database.createTask(task);

    // 5. 提交到AI服务
    try {
      const aiResult = await this.aiClient.createTask({
        inputUrls: uploadedFiles,
        prompt,
        parameters,
      });

      // 更新任务状态
      task.aiTaskId = aiResult.taskId;
      task.status = 'processing';
      await this.database.updateTask(task.id, {
        aiTaskId: aiResult.taskId,
        status: 'processing',
      });

      return task;
    } catch (error) {
      // 处理失败，退还积分
      if (credits && credits > 0) {
        await this.refundCredits(userId, credits);
      }

      task.status = 'failed';
      task.error = (error as Error).message;
      await this.database.updateTask(task.id, {
        status: 'failed',
        error: task.error,
      });

      throw error;
    }
  }

  /**
   * 更新任务状态
   */
  async updateTaskStatus(taskId: string): Promise<Task> {
    const task = await this.database.getTask(taskId);
    if (!task || !task.aiTaskId) {
      throw new Error('任务不存在或无效');
    }

    // 查询AI服务状态
    const aiStatus = await this.aiClient.getTaskStatus(task.aiTaskId);

    switch (aiStatus.status) {
      case 'processing':
        return task; // 状态无变化

      case 'completed':
        // 下载结果文件
        const resultUrls = await Promise.all(
          aiStatus.resultUrls.map(async (url, index) => {
            const key = this.storage.generateUniqueKey(
              `result_${index}.png`,
              'output'
            );
            const result = await this.storage.downloadAndUpload(url, key);
            return result.url;
          })
        );

        // 更新任务状态
        const updatedTask = {
          ...task,
          status: 'completed' as const,
          resultUrls,
          completedAt: new Date(),
        };

        await this.database.updateTask(taskId, {
          status: 'completed',
          resultUrls,
          completedAt: updatedTask.completedAt,
        });

        return updatedTask;

      case 'failed':
        // 任务失败，退还积分
        if (task.parameters.credits) {
          await this.refundCredits(task.userId, task.parameters.credits);
        }

        const failedTask = {
          ...task,
          status: 'failed' as const,
          error: aiStatus.error,
          completedAt: new Date(),
        };

        await this.database.updateTask(taskId, {
          status: 'failed',
          error: aiStatus.error,
          completedAt: failedTask.completedAt,
        });

        return failedTask;

      default:
        return task;
    }
  }

  /**
   * 获取用户任务列表
   */
  async getUserTasks(
    userId: string,
    limit: number = 20,
    offset: number = 0
  ): Promise<Task[]> {
    return this.database.getUserTasks(userId, limit, offset);
  }

  /**
   * 验证并消费积分
   */
  private async validateAndConsumeCredits(
    userId: string,
    credits: number
  ): Promise<void> {
    const userCredits = await this.database.getUserCredits(userId);
    if (userCredits < credits) {
      throw new Error('积分不足');
    }

    await this.database.consumeCredits(userId, credits);
  }

  /**
   * 退还积分
   */
  private async refundCredits(userId: string, credits: number): Promise<void> {
    await this.database.addCredits(userId, credits, '任务失败退款');
  }

  /**
   * 生成任务ID
   */
  private generateTaskId(): string {
    return `task_${Date.now()}_${Math.random().toString(36).substring(2)}`;
  }
}
```

### 5. 环境配置文件

**文件**: `.env.example`

```bash
# 应用基础配置
APP_NAME="我的AI图片处理器"
APP_VERSION="1.0.0"
NODE_ENV="development"
PORT=3000
DOMAIN="http://localhost:3000"

# 数据库配置
DATABASE_URL="./database.sqlite"
# 或者使用 PostgreSQL
# DATABASE_URL="postgresql://username:password@localhost:5432/myapp"

# 存储配置 (选择一个)
# Cloudflare R2
STORAGE_PROVIDER="r2"
R2_BUCKET_NAME="my-ai-images"
R2_ACCESS_KEY_ID="your-r2-access-key"
R2_SECRET_ACCESS_KEY="your-r2-secret-key"
R2_ENDPOINT="https://your-account-id.r2.cloudflarestorage.com"
CDN_URL="https://your-cdn-domain.com"

# 或者 AWS S3
# STORAGE_PROVIDER="s3"
# S3_BUCKET_NAME="my-ai-images"
# S3_ACCESS_KEY_ID="your-s3-access-key"
# S3_SECRET_ACCESS_KEY="your-s3-secret-key"
# S3_REGION="us-east-1"

# AI服务配置
# OpenAI
OPENAI_API_KEY="sk-your-openai-api-key"
OPENAI_BASE_URL="https://api.openai.com/v1"

# Stability AI
STABILITY_API_KEY="sk-your-stability-api-key"
STABILITY_BASE_URL="https://api.stability.ai/v1"

# 默认AI提供商
DEFAULT_AI_PROVIDER="openai"

# Webhook配置
WEBHOOK_SECRET="your-webhook-secret-key"

# 业务配置
NEW_USER_CREDITS=10
TASK_COST_CREDITS=1
MAX_FILE_SIZE_MB=100
MAX_FILES_PER_TASK=5
MAX_TASKS_PER_USER=100
MAX_TASKS_PER_DAY=50

# 安全配置
JWT_SECRET="your-jwt-secret-key"
ENCRYPTION_KEY="your-encryption-key"

# 监控配置
LOG_LEVEL="info"
ENABLE_METRICS="true"
ENABLE_TRACING="false"

# 邮件配置（可选）
SMTP_HOST="smtp.gmail.com"
SMTP_PORT=587
SMTP_USER="your-email@gmail.com"
SMTP_PASS="your-email-password"

# 支付配置（可选）
STRIPE_PUBLIC_KEY="pk_test_your-stripe-public-key"
STRIPE_SECRET_KEY="sk_test_your-stripe-secret-key"
STRIPE_WEBHOOK_SECRET="whsec_your-stripe-webhook-secret"
```

### 6. 数据库初始化脚本

**文件**: `backend/src/database/schema.sql`

```sql
-- 用户表
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  username TEXT UNIQUE,
  password_hash TEXT,
  avatar_url TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 用户积分表
CREATE TABLE IF NOT EXISTS user_credits (
  user_id TEXT PRIMARY KEY,
  credits INTEGER DEFAULT 0,
  total_earned INTEGER DEFAULT 0,
  total_spent INTEGER DEFAULT 0,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- AI任务表
CREATE TABLE IF NOT EXISTS ai_tasks (
  id TEXT PRIMARY KEY,
  task_no TEXT UNIQUE NOT NULL,
  user_id TEXT NOT NULL,
  task_type TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending',
  ai_provider TEXT NOT NULL,
  ai_model TEXT,
  ai_task_id TEXT,
  
  -- 输入数据
  input_files TEXT, -- JSON array
  input_parameters TEXT, -- JSON object
  prompt TEXT,
  
  -- 输出数据
  result_urls TEXT, -- JSON array
  result_metadata TEXT, -- JSON object
  
  -- 错误信息
  error_message TEXT,
  retry_count INTEGER DEFAULT 0,
  
  -- 时间戳
  estimated_completion_at DATETIME,
  started_at DATETIME,
  completed_at DATETIME,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 积分交易记录表
CREATE TABLE IF NOT EXISTS credit_transactions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  task_id TEXT,
  transaction_type TEXT NOT NULL, -- 'earn', 'spend', 'refund'
  amount INTEGER NOT NULL,
  balance_before INTEGER NOT NULL,
  balance_after INTEGER NOT NULL,
  description TEXT,
  metadata TEXT, -- JSON object
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (task_id) REFERENCES ai_tasks(id) ON DELETE SET NULL
);

-- 系统配置表
CREATE TABLE IF NOT EXISTS system_config (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  description TEXT,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_ai_tasks_user_id ON ai_tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_ai_tasks_status ON ai_tasks(status);
CREATE INDEX IF NOT EXISTS idx_ai_tasks_created_at ON ai_tasks(created_at);
CREATE INDEX IF NOT EXISTS idx_ai_tasks_task_type ON ai_tasks(task_type);

CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_id ON credit_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_credit_transactions_created_at ON credit_transactions(created_at);

-- 插入默认配置
INSERT OR IGNORE INTO system_config (key, value, description) VALUES
('new_user_credits', '10', '新用户注册赠送积分'),
('task_cost_credits', '1', '每个任务消耗积分'),
('max_file_size_mb', '100', '最大文件大小(MB)'),
('max_files_per_task', '5', '每个任务最大文件数'),
('max_tasks_per_day', '50', '每日最大任务数');
```

### 7. 部署配置

**文件**: `docker-compose.yml`

```yaml
version: '3.8'

services:
  # 前端服务
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - VITE_API_BASE_URL=http://backend:8000
    depends_on:
      - backend
    volumes:
      - ./frontend:/app
      - /app/node_modules

  # 后端服务
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - NODE_ENV=development
      - DATABASE_URL=postgresql://postgres:password@postgres:5432/aiapp
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
    volumes:
      - ./backend:/app
      - /app/node_modules
      - ./uploads:/app/uploads

  # 数据库
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=aiapp
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backend/src/database/schema.sql:/docker-entrypoint-initdb.d/schema.sql

  # Redis缓存
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend

volumes:
  postgres_data:
  redis_data:
```

## 🚀 快速开始脚本

**文件**: `scripts/setup.sh`

```bash
#!/bin/bash

# AI图片生成项目快速设置脚本

echo "🚀 开始设置AI图片生成项目..."

# 检查Node.js
if ! command -v node &> /dev/null; then
    echo "❌ 请先安装Node.js"
    exit 1
fi

# 检查pnpm
if ! command -v pnpm &> /dev/null; then
    echo "📦 安装pnpm..."
    npm install -g pnpm
fi

# 复制环境变量文件
if [ ! -f .env ]; then
    echo "📝 创建环境变量文件..."
    cp .env.example .env
    echo "⚠️  请编辑 .env 文件配置你的API密钥"
fi

# 安装前端依赖
echo "📦 安装前端依赖..."
cd frontend
pnpm install
cd ..

# 安装后端依赖
echo "📦 安装后端依赖..."
cd backend
pnpm install
cd ..

# 初始化数据库
echo "🗄️ 初始化数据库..."
node scripts/db-migrate.js

# 创建必要目录
echo "📁 创建目录结构..."
mkdir -p uploads/input
mkdir -p uploads/output
mkdir -p uploads/temp
mkdir -p logs

echo "✅ 项目设置完成！"
echo ""
echo "下一步："
echo "1. 编辑 .env 文件配置API密钥"
echo "2. 运行 'pnpm dev' 启动开发服务器"
echo "3. 访问 http://localhost:3000"
echo ""
echo "📚 查看文档："
echo "- README.md - 项目介绍"
echo "- docs/API.md - API文档"
echo "- docs/DEVELOPMENT.md - 开发指南"
```

## 📚 使用说明

### 1. 创建新项目

```bash
# 1. 创建项目目录
mkdir my-ai-image-app
cd my-ai-image-app

# 2. 复制模板结构
# 按照上面的目录结构创建文件和文件夹

# 3. 运行设置脚本
chmod +x scripts/setup.sh
./scripts/setup.sh

# 4. 配置环境变量
vim .env

# 5. 启动开发服务器
pnpm dev
```

### 2. 自定义配置

根据你的具体需求修改以下文件：

- **提示词模板**: `backend/src/services/prompt-builder.ts`
- **AI服务适配器**: `backend/src/services/ai-client.ts`
- **前端界面**: `frontend/src/components/`
- **业务逻辑**: `backend/src/controllers/`

### 3. 部署到生产环境

```bash
# 使用Docker部署
docker-compose up -d

# 或者使用Cloudflare Workers
cd backend
npx wrangler deploy

# 部署前端到Vercel/Netlify
cd frontend
npm run build
```

这个模板提供了完整的项目结构和核心代码，你可以根据具体需求进行定制和扩展。