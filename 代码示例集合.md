# ğŸ’» AIå›¾ç‰‡ç”Ÿæˆç³»ç»Ÿ - ä»£ç ç¤ºä¾‹é›†åˆ

> è¿™é‡Œæä¾›äº†å®Œæ•´çš„ä»£ç ç¤ºä¾‹ï¼Œä½ å¯ä»¥ç›´æ¥å¤åˆ¶ä½¿ç”¨ï¼

## ğŸ“ ç›®å½•ç»“æ„

```
ä½ çš„é¡¹ç›®/
â”œâ”€â”€ frontend/          # å‰ç«¯ä»£ç 
â”œâ”€â”€ backend/           # åç«¯ä»£ç 
â”œâ”€â”€ shared/            # å…±äº«ä»£ç 
â””â”€â”€ docs/              # æ–‡æ¡£
```

## ğŸ¨ å‰ç«¯ä»£ç ç¤ºä¾‹

### 1. æ–‡ä»¶ä¸Šä¼ ç»„ä»¶ (React + TypeScript)

**æ–‡ä»¶**: `frontend/src/components/FileUpload.tsx`

```typescript
import React, { useState, useCallback } from 'react';
import './FileUpload.css';

interface FileUploadProps {
  onFileSelect: (files: File[]) => void;
  maxFiles?: number;
  maxSizeMB?: number;
  acceptedTypes?: string[];
  disabled?: boolean;
}

export const FileUpload: React.FC<FileUploadProps> = ({
  onFileSelect,
  maxFiles = 1,
  maxSizeMB = 10,
  acceptedTypes = ['image/jpeg', 'image/png', 'image/webp'],
  disabled = false
}) => {
  const [dragActive, setDragActive] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
  const [errors, setErrors] = useState<string[]>([]);

  // éªŒè¯æ–‡ä»¶
  const validateFile = useCallback((file: File): string | null => {
    // æ£€æŸ¥æ–‡ä»¶ç±»å‹
    if (!acceptedTypes.includes(file.type)) {
      return `ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${file.name}`;
    }

    // æ£€æŸ¥æ–‡ä»¶å¤§å°
    const sizeMB = file.size / (1024 * 1024);
    if (sizeMB > maxSizeMB) {
      return `æ–‡ä»¶å¤ªå¤§: ${file.name} (${sizeMB.toFixed(1)}MB > ${maxSizeMB}MB)`;
    }

    return null;
  }, [acceptedTypes, maxSizeMB]);

  // å¤„ç†æ–‡ä»¶é€‰æ‹©
  const handleFiles = useCallback((fileList: FileList | null) => {
    if (!fileList) return;

    const files = Array.from(fileList);
    const newErrors: string[] = [];
    const validFiles: File[] = [];

    // æ£€æŸ¥æ–‡ä»¶æ•°é‡
    if (files.length > maxFiles) {
      newErrors.push(`æœ€å¤šåªèƒ½é€‰æ‹© ${maxFiles} ä¸ªæ–‡ä»¶`);
    }

    // éªŒè¯æ¯ä¸ªæ–‡ä»¶
    files.slice(0, maxFiles).forEach(file => {
      const error = validateFile(file);
      if (error) {
        newErrors.push(error);
      } else {
        validFiles.push(file);
      }
    });

    setErrors(newErrors);
    setSelectedFiles(validFiles);
    
    if (validFiles.length > 0) {
      onFileSelect(validFiles);
    }
  }, [maxFiles, validateFile, onFileSelect]);

  // æ‹–æ‹½å¤„ç†
  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (disabled) return;
    handleFiles(e.dataTransfer.files);
  }, [handleFiles, disabled]);

  const handleInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    handleFiles(e.target.files);
  }, [handleFiles]);

  // ç§»é™¤æ–‡ä»¶
  const removeFile = useCallback((index: number) => {
    const newFiles = selectedFiles.filter((_, i) => i !== index);
    setSelectedFiles(newFiles);
    onFileSelect(newFiles);
  }, [selectedFiles, onFileSelect]);

  return (
    <div className="file-upload">
      {/* ä¸Šä¼ åŒºåŸŸ */}
      <div
        className={`upload-area ${
          dragActive ? 'drag-active' : ''
        } ${disabled ? 'disabled' : ''}`}
        onDragEnter={handleDrag}
        onDragLeave={handleDrag}
        onDragOver={handleDrag}
        onDrop={handleDrop}
        onClick={() => !disabled && document.getElementById('file-input')?.click()}
      >
        <input
          id="file-input"
          type="file"
          multiple={maxFiles > 1}
          accept={acceptedTypes.join(',')}
          onChange={handleInputChange}
          disabled={disabled}
          style={{ display: 'none' }}
        />
        
        <div className="upload-content">
          <div className="upload-icon">ğŸ“</div>
          <h3>é€‰æ‹©å›¾ç‰‡æ–‡ä»¶</h3>
          <p>æ‹–æ‹½æ–‡ä»¶åˆ°è¿™é‡Œæˆ–ç‚¹å‡»é€‰æ‹©</p>
          <div className="upload-info">
            <span>æ”¯æŒ: {acceptedTypes.map(type => type.split('/')[1].toUpperCase()).join(', ')}</span>
            <span>æœ€å¤§: {maxSizeMB}MB</span>
            {maxFiles > 1 && <span>æœ€å¤š: {maxFiles}ä¸ªæ–‡ä»¶</span>}
          </div>
        </div>
      </div>

      {/* å·²é€‰æ–‡ä»¶åˆ—è¡¨ */}
      {selectedFiles.length > 0 && (
        <div className="selected-files">
          <h4>å·²é€‰æ‹©çš„æ–‡ä»¶:</h4>
          {selectedFiles.map((file, index) => (
            <div key={index} className="file-item">
              <div className="file-info">
                <span className="file-name">{file.name}</span>
                <span className="file-size">
                  {(file.size / (1024 * 1024)).toFixed(1)}MB
                </span>
              </div>
              <button
                type="button"
                onClick={() => removeFile(index)}
                className="remove-btn"
              >
                âœ•
              </button>
            </div>
          ))}
        </div>
      )}

      {/* é”™è¯¯ä¿¡æ¯ */}
      {errors.length > 0 && (
        <div className="error-list">
          {errors.map((error, index) => (
            <div key={index} className="error-message">
              âš ï¸ {error}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

**æ ·å¼æ–‡ä»¶**: `frontend/src/components/FileUpload.css`

```css
.file-upload {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

.upload-area {
  border: 2px dashed #ccc;
  border-radius: 8px;
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  background: #fafafa;
}

.upload-area:hover {
  border-color: #007bff;
  background: #f0f8ff;
}

.upload-area.drag-active {
  border-color: #007bff;
  background: #e6f3ff;
  transform: scale(1.02);
}

.upload-area.disabled {
  opacity: 0.6;
  cursor: not-allowed;
  background: #f5f5f5;
}

.upload-content {
  pointer-events: none;
}

.upload-icon {
  font-size: 48px;
  margin-bottom: 16px;
}

.upload-content h3 {
  margin: 0 0 8px 0;
  color: #333;
  font-size: 18px;
}

.upload-content p {
  margin: 0 0 16px 0;
  color: #666;
  font-size: 14px;
}

.upload-info {
  display: flex;
  justify-content: center;
  gap: 16px;
  font-size: 12px;
  color: #999;
}

.selected-files {
  margin-top: 20px;
  padding: 16px;
  background: #f9f9f9;
  border-radius: 8px;
}

.selected-files h4 {
  margin: 0 0 12px 0;
  color: #333;
  font-size: 14px;
}

.file-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: white;
  border-radius: 4px;
  margin-bottom: 8px;
  border: 1px solid #eee;
}

.file-info {
  display: flex;
  flex-direction: column;
  flex: 1;
}

.file-name {
  font-size: 14px;
  color: #333;
  font-weight: 500;
}

.file-size {
  font-size: 12px;
  color: #666;
}

.remove-btn {
  background: #ff4757;
  color: white;
  border: none;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  cursor: pointer;
  font-size: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.remove-btn:hover {
  background: #ff3742;
}

.error-list {
  margin-top: 16px;
}

.error-message {
  padding: 8px 12px;
  background: #ffe6e6;
  border: 1px solid #ffcccc;
  border-radius: 4px;
  color: #d63031;
  font-size: 14px;
  margin-bottom: 8px;
}
```

### 2. ä»»åŠ¡è¿›åº¦ç»„ä»¶

**æ–‡ä»¶**: `frontend/src/components/TaskProgress.tsx`

```typescript
import React from 'react';
import './TaskProgress.css';

interface Task {
  id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress?: number;
  resultUrls?: string[];
  error?: string;
  createdAt: Date;
}

interface TaskProgressProps {
  tasks: Task[];
  onDownload?: (url: string) => void;
  onRetry?: (taskId: string) => void;
}

export const TaskProgress: React.FC<TaskProgressProps> = ({
  tasks,
  onDownload,
  onRetry
}) => {
  const getStatusIcon = (status: Task['status']) => {
    switch (status) {
      case 'pending': return 'â³';
      case 'processing': return 'ğŸ”„';
      case 'completed': return 'âœ…';
      case 'failed': return 'âŒ';
      default: return 'â“';
    }
  };

  const getStatusText = (status: Task['status']) => {
    switch (status) {
      case 'pending': return 'ç­‰å¾…å¤„ç†';
      case 'processing': return 'æ­£åœ¨å¤„ç†';
      case 'completed': return 'å¤„ç†å®Œæˆ';
      case 'failed': return 'å¤„ç†å¤±è´¥';
      default: return 'æœªçŸ¥çŠ¶æ€';
    }
  };

  const formatTime = (date: Date) => {
    return date.toLocaleString('zh-CN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  if (tasks.length === 0) {
    return (
      <div className="task-progress empty">
        <div className="empty-state">
          <div className="empty-icon">ğŸ“</div>
          <h3>æš‚æ— ä»»åŠ¡</h3>
          <p>ä¸Šä¼ å›¾ç‰‡å¼€å§‹ä½ çš„ç¬¬ä¸€ä¸ªAIå¤„ç†ä»»åŠ¡å§ï¼</p>
        </div>
      </div>
    );
  }

  return (
    <div className="task-progress">
      <h3>å¤„ç†ä»»åŠ¡ ({tasks.length})</h3>
      
      <div className="task-list">
        {tasks.map((task) => (
          <div key={task.id} className={`task-item ${task.status}`}>
            <div className="task-header">
              <div className="task-status">
                <span className="status-icon">{getStatusIcon(task.status)}</span>
                <span className="status-text">{getStatusText(task.status)}</span>
              </div>
              <div className="task-time">
                {formatTime(task.createdAt)}
              </div>
            </div>

            {/* è¿›åº¦æ¡ */}
            {task.status === 'processing' && (
              <div className="progress-bar">
                <div 
                  className="progress-fill"
                  style={{ width: `${task.progress || 0}%` }}
                />
                <span className="progress-text">
                  {task.progress || 0}%
                </span>
              </div>
            )}

            {/* é”™è¯¯ä¿¡æ¯ */}
            {task.status === 'failed' && task.error && (
              <div className="error-info">
                <p>é”™è¯¯åŸå› : {task.error}</p>
                {onRetry && (
                  <button 
                    onClick={() => onRetry(task.id)}
                    className="retry-btn"
                  >
                    é‡è¯•
                  </button>
                )}
              </div>
            )}

            {/* ç»“æœå±•ç¤º */}
            {task.status === 'completed' && task.resultUrls && (
              <div className="result-gallery">
                <h4>å¤„ç†ç»“æœ:</h4>
                <div className="result-images">
                  {task.resultUrls.map((url, index) => (
                    <div key={index} className="result-item">
                      <img 
                        src={url} 
                        alt={`ç»“æœ ${index + 1}`}
                        className="result-image"
                      />
                      {onDownload && (
                        <button 
                          onClick={() => onDownload(url)}
                          className="download-btn"
                        >
                          ä¸‹è½½
                        </button>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  );
};
```

### 3. è‡ªå®šä¹‰Hook - ä»»åŠ¡è½®è¯¢

**æ–‡ä»¶**: `frontend/src/hooks/useTaskPolling.ts`

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';

interface Task {
  id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress?: number;
  resultUrls?: string[];
  error?: string;
}

interface UseTaskPollingOptions {
  intervalMs?: number;        // è½®è¯¢é—´éš”ï¼ˆæ¯«ç§’ï¼‰
  maxAttempts?: number;       // æœ€å¤§è½®è¯¢æ¬¡æ•°
  onTaskComplete?: (task: Task) => void;  // ä»»åŠ¡å®Œæˆå›è°ƒ
  onTaskFailed?: (task: Task) => void;    // ä»»åŠ¡å¤±è´¥å›è°ƒ
}

export const useTaskPolling = (
  initialTasks: Task[] = [],
  options: UseTaskPollingOptions = {}
) => {
  const {
    intervalMs = 2000,
    maxAttempts = 150, // 5åˆ†é’Ÿ
    onTaskComplete,
    onTaskFailed
  } = options;

  const [tasks, setTasks] = useState<Task[]>(initialTasks);
  const [isPolling, setIsPolling] = useState(false);
  const [attempts, setAttempts] = useState(0);
  
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const attemptsRef = useRef(0);

  // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å®Œæˆ
  const isTaskCompleted = useCallback((task: Task): boolean => {
    return task.status === 'completed' || task.status === 'failed';
  }, []);

  // è·å–ä»»åŠ¡çŠ¶æ€
  const fetchTaskStatus = useCallback(async (taskId: string): Promise<Task | null> => {
    try {
      const response = await fetch(`/api/tasks/${taskId}/status`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      console.error(`è·å–ä»»åŠ¡ ${taskId} çŠ¶æ€å¤±è´¥:`, error);
      return null;
    }
  }, []);

  // æ›´æ–°å•ä¸ªä»»åŠ¡
  const updateTask = useCallback(async (task: Task): Promise<Task> => {
    if (isTaskCompleted(task)) {
      return task; // å·²å®Œæˆçš„ä»»åŠ¡ä¸éœ€è¦æ›´æ–°
    }

    const updatedTask = await fetchTaskStatus(task.id);
    if (!updatedTask) {
      return task; // è·å–å¤±è´¥ï¼Œä¿æŒåŸçŠ¶æ€
    }

    // è§¦å‘å›è°ƒ
    if (updatedTask.status === 'completed' && onTaskComplete) {
      onTaskComplete(updatedTask);
    } else if (updatedTask.status === 'failed' && onTaskFailed) {
      onTaskFailed(updatedTask);
    }

    return updatedTask;
  }, [isTaskCompleted, fetchTaskStatus, onTaskComplete, onTaskFailed]);

  // è½®è¯¢é€»è¾‘
  const pollTasks = useCallback(async () => {
    try {
      const updatedTasks = await Promise.all(
        tasks.map(updateTask)
      );
      
      setTasks(updatedTasks);
      
      // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡éƒ½å®Œæˆäº†
      const allCompleted = updatedTasks.every(isTaskCompleted);
      if (allCompleted) {
        setIsPolling(false);
        return;
      }

      // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§è½®è¯¢æ¬¡æ•°
      attemptsRef.current += 1;
      setAttempts(attemptsRef.current);
      
      if (attemptsRef.current >= maxAttempts) {
        console.warn('è¾¾åˆ°æœ€å¤§è½®è¯¢æ¬¡æ•°ï¼Œåœæ­¢è½®è¯¢');
        setIsPolling(false);
        return;
      }

    } catch (error) {
      console.error('è½®è¯¢ä»»åŠ¡çŠ¶æ€å¤±è´¥:', error);
    }
  }, [tasks, updateTask, isTaskCompleted, maxAttempts]);

  // å¼€å§‹è½®è¯¢
  const startPolling = useCallback(() => {
    if (isPolling) return;
    
    setIsPolling(true);
    attemptsRef.current = 0;
    setAttempts(0);
    
    // ç«‹å³æ‰§è¡Œä¸€æ¬¡
    pollTasks();
    
    // è®¾ç½®å®šæ—¶å™¨
    intervalRef.current = setInterval(pollTasks, intervalMs);
  }, [isPolling, pollTasks, intervalMs]);

  // åœæ­¢è½®è¯¢
  const stopPolling = useCallback(() => {
    setIsPolling(false);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);

  // æ·»åŠ æ–°ä»»åŠ¡
  const addTask = useCallback((newTask: Task) => {
    setTasks(prev => [...prev, newTask]);
    
    // å¦‚æœæœ‰æœªå®Œæˆçš„ä»»åŠ¡ä¸”æ²¡æœ‰åœ¨è½®è¯¢ï¼Œåˆ™å¼€å§‹è½®è¯¢
    if (!isTaskCompleted(newTask) && !isPolling) {
      startPolling();
    }
  }, [isTaskCompleted, isPolling, startPolling]);

  // ç§»é™¤ä»»åŠ¡
  const removeTask = useCallback((taskId: string) => {
    setTasks(prev => prev.filter(task => task.id !== taskId));
  }, []);

  // æ¸…ç©ºæ‰€æœ‰ä»»åŠ¡
  const clearTasks = useCallback(() => {
    setTasks([]);
    stopPolling();
  }, [stopPolling]);

  // ç»„ä»¶å¸è½½æ—¶æ¸…ç†
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  // å½“ä»»åŠ¡åˆ—è¡¨å˜åŒ–æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦å¼€å§‹æˆ–åœæ­¢è½®è¯¢
  useEffect(() => {
    const hasIncompleteTasks = tasks.some(task => !isTaskCompleted(task));
    
    if (hasIncompleteTasks && !isPolling) {
      startPolling();
    } else if (!hasIncompleteTasks && isPolling) {
      stopPolling();
    }
  }, [tasks, isPolling, isTaskCompleted, startPolling, stopPolling]);

  return {
    tasks,
    setTasks,
    isPolling,
    attempts,
    maxAttempts,
    startPolling,
    stopPolling,
    addTask,
    removeTask,
    clearTasks,
    allCompleted: tasks.every(isTaskCompleted),
    completedCount: tasks.filter(task => task.status === 'completed').length,
    failedCount: tasks.filter(task => task.status === 'failed').length,
    processingCount: tasks.filter(task => task.status === 'processing').length
  };
};
```

## ğŸ”§ åç«¯ä»£ç ç¤ºä¾‹

### 1. æ–‡ä»¶å­˜å‚¨æœåŠ¡

**æ–‡ä»¶**: `backend/src/services/storage.ts`

```typescript
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import crypto from 'crypto';
import path from 'path';

export interface StorageConfig {
  provider: 'r2' | 's3';
  bucket: string;
  region?: string;
  accessKeyId: string;
  secretAccessKey: string;
  endpoint?: string;
  cdnUrl?: string;
}

export interface UploadResult {
  key: string;
  url: string;
  size: number;
  contentType: string;
}

export class StorageService {
  private client: S3Client;
  private config: StorageConfig;

  constructor(config: StorageConfig) {
    this.config = config;
    this.client = new S3Client({
      region: config.region || 'auto',
      credentials: {
        accessKeyId: config.accessKeyId,
        secretAccessKey: config.secretAccessKey,
      },
      endpoint: config.endpoint,
    });
  }

  /**
   * ä¸Šä¼ æ–‡ä»¶åˆ°å­˜å‚¨æœåŠ¡
   */
  async uploadFile(
    file: Buffer | Uint8Array,
    key: string,
    contentType: string = 'application/octet-stream'
  ): Promise<UploadResult> {
    try {
      const command = new PutObjectCommand({
        Bucket: this.config.bucket,
        Key: key,
        Body: file,
        ContentType: contentType,
      });

      await this.client.send(command);

      return {
        key,
        url: this.getPublicUrl(key),
        size: file.length,
        contentType,
      };
    } catch (error) {
      console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
      throw new Error(`æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ${(error as Error).message}`);
    }
  }

  /**
   * ä»URLä¸‹è½½æ–‡ä»¶å¹¶ä¸Šä¼ åˆ°å­˜å‚¨
   */
  async downloadAndUpload(
    sourceUrl: string,
    destinationKey: string
  ): Promise<UploadResult> {
    try {
      console.log(`å¼€å§‹ä¸‹è½½æ–‡ä»¶: ${sourceUrl}`);
      
      const response = await fetch(sourceUrl);
      if (!response.ok) {
        throw new Error(`ä¸‹è½½å¤±è´¥: ${response.status} ${response.statusText}`);
      }

      const arrayBuffer = await response.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);
      const contentType = response.headers.get('content-type') || 'application/octet-stream';

      console.log(`æ–‡ä»¶ä¸‹è½½å®Œæˆï¼Œå¤§å°: ${buffer.length} bytes`);
      
      return await this.uploadFile(buffer, destinationKey, contentType);
    } catch (error) {
      console.error('ä¸‹è½½å¹¶ä¸Šä¼ æ–‡ä»¶å¤±è´¥:', error);
      throw new Error(`ä¸‹è½½å¹¶ä¸Šä¼ æ–‡ä»¶å¤±è´¥: ${(error as Error).message}`);
    }
  }

  /**
   * ç”Ÿæˆå…¬å…±è®¿é—®URL
   */
  getPublicUrl(key: string): string {
    if (this.config.cdnUrl) {
      return `${this.config.cdnUrl}/${key}`;
    }
    
    if (this.config.provider === 'r2') {
      return `https://${this.config.bucket}.r2.cloudflarestorage.com/${key}`;
    }
    
    return `https://${this.config.bucket}.s3.${this.config.region}.amazonaws.com/${key}`;
  }

  /**
   * ç”Ÿæˆé¢„ç­¾åä¸Šä¼ URL
   */
  async getPresignedUploadUrl(
    key: string,
    contentType: string,
    expiresIn: number = 3600
  ): Promise<string> {
    const command = new PutObjectCommand({
      Bucket: this.config.bucket,
      Key: key,
      ContentType: contentType,
    });

    return getSignedUrl(this.client, command, { expiresIn });
  }

  /**
   * ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
   */
  generateUniqueKey(originalName: string, folder: string = ''): string {
    const timestamp = Date.now();
    const random = crypto.randomBytes(4).toString('hex');
    const extension = path.extname(originalName);
    const baseName = path.basename(originalName, extension);
    
    // æ¸…ç†æ–‡ä»¶åï¼Œç§»é™¤ç‰¹æ®Šå­—ç¬¦
    const cleanBaseName = baseName.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_');
    
    const fileName = `${timestamp}_${random}_${cleanBaseName}${extension}`;
    return folder ? `${folder}/${fileName}` : fileName;
  }

  /**
   * æ‰¹é‡ä¸Šä¼ æ–‡ä»¶
   */
  async uploadFiles(
    files: Array<{ buffer: Buffer; name: string; contentType: string }>,
    folder: string = 'uploads'
  ): Promise<UploadResult[]> {
    const uploadPromises = files.map(file => {
      const key = this.generateUniqueKey(file.name, folder);
      return this.uploadFile(file.buffer, key, file.contentType);
    });

    return Promise.all(uploadPromises);
  }

  /**
   * åˆ é™¤æ–‡ä»¶
   */
  async deleteFile(key: string): Promise<void> {
    try {
      const command = new DeleteObjectCommand({
        Bucket: this.config.bucket,
        Key: key,
      });

      await this.client.send(command);
      console.log(`æ–‡ä»¶åˆ é™¤æˆåŠŸ: ${key}`);
    } catch (error) {
      console.error('æ–‡ä»¶åˆ é™¤å¤±è´¥:', error);
      throw new Error(`æ–‡ä»¶åˆ é™¤å¤±è´¥: ${(error as Error).message}`);
    }
  }
}

// å¯¼å‡ºé…ç½®å·¥å‚å‡½æ•°
export function createStorageService(): StorageService {
  const config: StorageConfig = {
    provider: (process.env.STORAGE_PROVIDER as 'r2' | 's3') || 'r2',
    bucket: process.env.R2_BUCKET_NAME || process.env.S3_BUCKET_NAME || '',
    accessKeyId: process.env.R2_ACCESS_KEY_ID || process.env.S3_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY || process.env.S3_SECRET_ACCESS_KEY || '',
    endpoint: process.env.R2_ENDPOINT,
    region: process.env.S3_REGION,
    cdnUrl: process.env.CDN_URL,
  };

  if (!config.bucket || !config.accessKeyId || !config.secretAccessKey) {
    throw new Error('å­˜å‚¨æœåŠ¡é…ç½®ä¸å®Œæ•´ï¼Œè¯·æ£€æŸ¥ç¯å¢ƒå˜é‡');
  }

  return new StorageService(config);
}
```

### 2. AIå®¢æˆ·ç«¯æœåŠ¡

**æ–‡ä»¶**: `backend/src/services/ai-client.ts`

```typescript
export interface AITaskRequest {
  inputUrls: string[];
  prompt: string;
  parameters: Record<string, any>;
}

export interface AITaskResponse {
  taskId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress?: number;
  resultUrls?: string[];
  error?: string;
  estimatedTime?: number;
}

export interface AIClientConfig {
  provider: 'openai' | 'stability' | 'custom';
  apiKey: string;
  baseUrl?: string;
  model?: string;
}

export abstract class BaseAIClient {
  protected config: AIClientConfig;

  constructor(config: AIClientConfig) {
    this.config = config;
  }

  abstract createTask(request: AITaskRequest): Promise<AITaskResponse>;
  abstract getTaskStatus(taskId: string): Promise<AITaskResponse>;
  abstract cancelTask(taskId: string): Promise<void>;
}

/**
 * OpenAIå®¢æˆ·ç«¯å®ç°
 */
export class OpenAIClient extends BaseAIClient {
  private apiKey: string;
  private baseUrl: string;

  constructor(config: AIClientConfig) {
    super(config);
    this.apiKey = config.apiKey;
    this.baseUrl = config.baseUrl || 'https://api.openai.com/v1';
  }

  async createTask(request: AITaskRequest): Promise<AITaskResponse> {
    try {
      const response = await fetch(`${this.baseUrl}/images/generations`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: this.config.model || 'dall-e-3',
          prompt: request.prompt,
          n: request.parameters.variants || 1,
          size: request.parameters.size || '1024x1024',
          quality: request.parameters.quality || 'standard',
          response_format: 'url',
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(`OpenAI APIé”™è¯¯: ${error.error?.message || response.statusText}`);
      }

      const data = await response.json();
      const taskId = `openai_${Date.now()}_${Math.random().toString(36).substring(2)}`;

      return {
        taskId,
        status: 'completed',
        resultUrls: data.data.map((item: any) => item.url),
      };
    } catch (error) {
      console.error('OpenAIä»»åŠ¡åˆ›å»ºå¤±è´¥:', error);
      throw error;
    }
  }

  async getTaskStatus(taskId: string): Promise<AITaskResponse> {
    // OpenAIçš„å›¾ç‰‡ç”Ÿæˆæ˜¯åŒæ­¥çš„ï¼Œæ‰€ä»¥è¿™é‡Œç›´æ¥è¿”å›å®ŒæˆçŠ¶æ€
    return {
      taskId,
      status: 'completed',
    };
  }

  async cancelTask(taskId: string): Promise<void> {
    // OpenAIçš„å›¾ç‰‡ç”Ÿæˆæ— æ³•å–æ¶ˆ
    throw new Error('OpenAIä»»åŠ¡æ— æ³•å–æ¶ˆ');
  }
}

/**
 * Stability AIå®¢æˆ·ç«¯å®ç°
 */
export class StabilityAIClient extends BaseAIClient {
  private apiKey: string;
  private baseUrl: string;

  constructor(config: AIClientConfig) {
    super(config);
    this.apiKey = config.apiKey;
    this.baseUrl = config.baseUrl || 'https://api.stability.ai/v1';
  }

  async createTask(request: AITaskRequest): Promise<AITaskResponse> {
    try {
      const formData = new FormData();
      formData.append('text_prompts[0][text]', request.prompt);
      formData.append('text_prompts[0][weight]', '1');
      formData.append('cfg_scale', request.parameters.cfgScale || '7');
      formData.append('height', request.parameters.height || '1024');
      formData.append('width', request.parameters.width || '1024');
      formData.append('samples', request.parameters.variants || '1');
      formData.append('steps', request.parameters.steps || '30');

      const response = await fetch(`${this.baseUrl}/generation/stable-diffusion-xl-1024-v1-0/text-to-image`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: formData,
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Stability AIé”™è¯¯: ${error.message || response.statusText}`);
      }

      const data = await response.json();
      const taskId = `stability_${Date.now()}_${Math.random().toString(36).substring(2)}`;

      // å°†base64å›¾ç‰‡è½¬æ¢ä¸ºURLï¼ˆéœ€è¦ä¸Šä¼ åˆ°å­˜å‚¨æœåŠ¡ï¼‰
      const resultUrls = await Promise.all(
        data.artifacts.map(async (artifact: any, index: number) => {
          const buffer = Buffer.from(artifact.base64, 'base64');
          // è¿™é‡Œéœ€è¦ä¸Šä¼ åˆ°å­˜å‚¨æœåŠ¡ï¼Œè¿”å›URL
          // å®é™…å®ç°ä¸­éœ€è¦æ³¨å…¥å­˜å‚¨æœåŠ¡
          return `data:image/png;base64,${artifact.base64}`;
        })
      );

      return {
        taskId,
        status: 'completed',
        resultUrls,
      };
    } catch (error) {
      console.error('Stability AIä»»åŠ¡åˆ›å»ºå¤±è´¥:', error);
      throw error;
    }
  }

  async getTaskStatus(taskId: string): Promise<AITaskResponse> {
    return {
      taskId,
      status: 'completed',
    };
  }

  async cancelTask(taskId: string): Promise<void> {
    throw new Error('Stability AIä»»åŠ¡æ— æ³•å–æ¶ˆ');
  }
}

/**
 * AIå®¢æˆ·ç«¯å·¥å‚
 */
export function createAIClient(config: AIClientConfig): BaseAIClient {
  switch (config.provider) {
    case 'openai':
      return new OpenAIClient(config);
    case 'stability':
      return new StabilityAIClient(config);
    default:
      throw new Error(`ä¸æ”¯æŒçš„AIæä¾›å•†: ${config.provider}`);
  }
}

/**
 * ä»ç¯å¢ƒå˜é‡åˆ›å»ºAIå®¢æˆ·ç«¯
 */
export function createAIClientFromEnv(): BaseAIClient {
  const provider = (process.env.DEFAULT_AI_PROVIDER as any) || 'openai';
  
  const configs = {
    openai: {
      provider: 'openai' as const,
      apiKey: process.env.OPENAI_API_KEY || '',
      baseUrl: process.env.OPENAI_BASE_URL,
      model: process.env.OPENAI_MODEL,
    },
    stability: {
      provider: 'stability' as const,
      apiKey: process.env.STABILITY_API_KEY || '',
      baseUrl: process.env.STABILITY_BASE_URL,
    },
  };

  const config = configs[provider];
  if (!config || !config.apiKey) {
    throw new Error(`AIæœåŠ¡é…ç½®ä¸å®Œæ•´: ${provider}`);
  }

  return createAIClient(config);
}
```

### 3. ä»»åŠ¡ç®¡ç†æœåŠ¡

**æ–‡ä»¶**: `backend/src/services/task-manager.ts`

```typescript
import { StorageService } from './storage';
import { BaseAIClient } from './ai-client';
import { DatabaseService } from './database';
import crypto from 'crypto';

export interface CreateTaskOptions {
  userId: string;
  files: Array<{ buffer: Buffer; name: string; contentType: string }>;
  parameters: Record<string, any>;
  taskType: string;
  credits?: number;
}

export interface Task {
  id: string;
  taskNo: string;
  userId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  taskType: string;
  aiProvider: string;
  aiTaskId?: string;
  inputFiles: string[];
  inputParameters: Record<string, any>;
  prompt?: string;
  resultUrls?: string[];
  errorMessage?: string;
  retryCount: number;
  estimatedCompletionAt?: Date;
  startedAt?: Date;
  completedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

export class TaskManager {
  constructor(
    private storage: StorageService,
    private aiClient: BaseAIClient,
    private database: DatabaseService
  ) {}

  /**
   * åˆ›å»ºæ–°çš„AIä»»åŠ¡
   */
  async createTask(options: CreateTaskOptions): Promise<Task> {
    const { userId, files, parameters, taskType, credits = 0 } = options;

    // 1. éªŒè¯ç”¨æˆ·ç§¯åˆ†
    if (credits > 0) {
      await this.validateAndConsumeCredits(userId, credits);
    }

    try {
      // 2. ä¸Šä¼ è¾“å…¥æ–‡ä»¶
      console.log(`å¼€å§‹ä¸Šä¼  ${files.length} ä¸ªæ–‡ä»¶`);
      const uploadResults = await this.storage.uploadFiles(files, 'input');
      const inputFiles = uploadResults.map(result => result.url);
      console.log('æ–‡ä»¶ä¸Šä¼ å®Œæˆ:', inputFiles);

      // 3. ç”Ÿæˆæç¤ºè¯
      const prompt = this.buildPrompt(taskType, parameters);
      console.log('ç”Ÿæˆçš„æç¤ºè¯:', prompt);

      // 4. åˆ›å»ºæ•°æ®åº“è®°å½•
      const task: Task = {
        id: this.generateTaskId(),
        taskNo: this.generateTaskNo(),
        userId,
        status: 'pending',
        taskType,
        aiProvider: 'openai', // å¯ä»¥æ ¹æ®é…ç½®åŠ¨æ€è®¾ç½®
        inputFiles,
        inputParameters: parameters,
        prompt,
        retryCount: 0,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      await this.database.createTask(task);
      console.log('ä»»åŠ¡åˆ›å»ºæˆåŠŸ:', task.id);

      // 5. å¼‚æ­¥æäº¤åˆ°AIæœåŠ¡
      this.submitToAI(task).catch(error => {
        console.error('æäº¤AIä»»åŠ¡å¤±è´¥:', error);
        this.handleTaskError(task.id, error.message);
      });

      return task;
    } catch (error) {
      // å¤„ç†å¤±è´¥ï¼Œé€€è¿˜ç§¯åˆ†
      if (credits > 0) {
        await this.refundCredits(userId, credits, 'ä»»åŠ¡åˆ›å»ºå¤±è´¥');
      }
      throw error;
    }
  }

  /**
   * æäº¤ä»»åŠ¡åˆ°AIæœåŠ¡
   */
  private async submitToAI(task: Task): Promise<void> {
    try {
      // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå¤„ç†ä¸­
      await this.database.updateTask(task.id, {
        status: 'processing',
        startedAt: new Date(),
        updatedAt: new Date(),
      });

      // è°ƒç”¨AIæœåŠ¡
      const aiResult = await this.aiClient.createTask({
        inputUrls: task.inputFiles,
        prompt: task.prompt || '',
        parameters: task.inputParameters,
      });

      // æ›´æ–°AIä»»åŠ¡ID
      await this.database.updateTask(task.id, {
        aiTaskId: aiResult.taskId,
        updatedAt: new Date(),
      });

      // å¦‚æœAIæœåŠ¡ç›´æ¥è¿”å›ç»“æœï¼ˆåŒæ­¥å¤„ç†ï¼‰
      if (aiResult.status === 'completed' && aiResult.resultUrls) {
        await this.handleTaskCompletion(task.id, aiResult.resultUrls);
      }
    } catch (error) {
      await this.handleTaskError(task.id, (error as Error).message);
      throw error;
    }
  }

  /**
   * å¤„ç†ä»»åŠ¡å®Œæˆ
   */
  private async handleTaskCompletion(taskId: string, resultUrls: string[]): Promise<void> {
    try {
      // ä¸‹è½½ç»“æœæ–‡ä»¶åˆ°æˆ‘ä»¬çš„å­˜å‚¨
      const downloadPromises = resultUrls.map(async (url, index) => {
        const key = this.storage.generateUniqueKey(`result_${index}.png`, 'output');
        const result = await this.storage.downloadAndUpload(url, key);
        return result.url;
      });

      const finalResultUrls = await Promise.all(downloadPromises);

      // æ›´æ–°ä»»åŠ¡çŠ¶æ€
      await this.database.updateTask(taskId, {
        status: 'completed',
        resultUrls: finalResultUrls,
        completedAt: new Date(),
        updatedAt: new Date(),
      });

      console.log(`ä»»åŠ¡ ${taskId} å®Œæˆï¼Œç»“æœ:`, finalResultUrls);
    } catch (error) {
      console.error(`å¤„ç†ä»»åŠ¡å®Œæˆå¤±è´¥ ${taskId}:`, error);
      await this.handleTaskError(taskId, `ç»“æœå¤„ç†å¤±è´¥: ${(error as Error).message}`);
    }
  }

  /**
   * å¤„ç†ä»»åŠ¡é”™è¯¯
   */
  private async handleTaskError(taskId: string, errorMessage: string): Promise<void> {
    try {
      const task = await this.database.getTask(taskId);
      if (!task) return;

      // é€€è¿˜ç§¯åˆ†
      const credits = task.inputParameters.credits || 0;
      if (credits > 0) {
        await this.refundCredits(task.userId, credits, 'ä»»åŠ¡å¤±è´¥é€€æ¬¾');
      }

      // æ›´æ–°ä»»åŠ¡çŠ¶æ€
      await this.database.updateTask(taskId, {
        status: 'failed',
        errorMessage,
        completedAt: new Date(),
        updatedAt: new Date(),
      });

      console.log(`ä»»åŠ¡ ${taskId} å¤±è´¥:`, errorMessage);
    } catch (error) {
      console.error(`å¤„ç†ä»»åŠ¡é”™è¯¯å¤±è´¥ ${taskId}:`, error);
    }
  }

  /**
   * è·å–ä»»åŠ¡çŠ¶æ€
   */
  async getTaskStatus(taskId: string): Promise<Task | null> {
    const task = await this.database.getTask(taskId);
    if (!task) return null;

    // å¦‚æœä»»åŠ¡è¿˜åœ¨å¤„ç†ä¸­ï¼ŒæŸ¥è¯¢AIæœåŠ¡çŠ¶æ€
    if (task.status === 'processing' && task.aiTaskId) {
      try {
        const aiStatus = await this.aiClient.getTaskStatus(task.aiTaskId);
        
        if (aiStatus.status === 'completed' && aiStatus.resultUrls) {
          await this.handleTaskCompletion(task.id, aiStatus.resultUrls);
          return await this.database.getTask(taskId); // è¿”å›æ›´æ–°åçš„ä»»åŠ¡
        } else if (aiStatus.status === 'failed') {
          await this.handleTaskError(task.id, aiStatus.error || 'æœªçŸ¥é”™è¯¯');
          return await this.database.getTask(taskId);
        }
      } catch (error) {
        console.error('æŸ¥è¯¢AIä»»åŠ¡çŠ¶æ€å¤±è´¥:', error);
      }
    }

    return task;
  }

  /**
   * è·å–ç”¨æˆ·ä»»åŠ¡åˆ—è¡¨
   */
  async getUserTasks(
    userId: string,
    limit: number = 20,
    offset: number = 0
  ): Promise<{ tasks: Task[]; total: number }> {
    return this.database.getUserTasks(userId, limit, offset);
  }

  /**
   * é‡è¯•å¤±è´¥çš„ä»»åŠ¡
   */
  async retryTask(taskId: string): Promise<Task> {
    const task = await this.database.getTask(taskId);
    if (!task) {
      throw new Error('ä»»åŠ¡ä¸å­˜åœ¨');
    }

    if (task.status !== 'failed') {
      throw new Error('åªèƒ½é‡è¯•å¤±è´¥çš„ä»»åŠ¡');
    }

    if (task.retryCount >= 3) {
      throw new Error('é‡è¯•æ¬¡æ•°å·²è¾¾ä¸Šé™');
    }

    // é‡ç½®ä»»åŠ¡çŠ¶æ€
    const updatedTask = {
      ...task,
      status: 'pending' as const,
      errorMessage: undefined,
      retryCount: task.retryCount + 1,
      updatedAt: new Date(),
    };

    await this.database.updateTask(taskId, updatedTask);

    // é‡æ–°æäº¤åˆ°AIæœåŠ¡
    this.submitToAI(updatedTask).catch(error => {
      console.error('é‡è¯•ä»»åŠ¡å¤±è´¥:', error);
      this.handleTaskError(taskId, error.message);
    });

    return updatedTask;
  }

  /**
   * æ„å»ºæç¤ºè¯
   */
  private buildPrompt(taskType: string, parameters: Record<string, any>): string {
    // è¿™é‡Œå¯ä»¥æ ¹æ®ä¸åŒçš„ä»»åŠ¡ç±»å‹æ„å»ºä¸åŒçš„æç¤ºè¯
    switch (taskType) {
      case 'style_transfer':
        return `Transform the image with ${parameters.style} style, maintaining the original composition and subject.`;
      case 'background_removal':
        return 'Remove the background from the image, keeping only the main subject.';
      case 'color_enhancement':
        return `Enhance the colors in the image with ${parameters.enhancement} effect.`;
      default:
        return parameters.prompt || 'Process the image according to the specified parameters.';
    }
  }

  /**
   * éªŒè¯å¹¶æ¶ˆè´¹ç§¯åˆ†
   */
  private async validateAndConsumeCredits(userId: string, credits: number): Promise<void> {
    const userCredits = await this.database.getUserCredits(userId);
    if (userCredits < credits) {
      throw new Error(`ç§¯åˆ†ä¸è¶³ï¼Œéœ€è¦ ${credits} ç§¯åˆ†ï¼Œå½“å‰åªæœ‰ ${userCredits} ç§¯åˆ†`);
    }

    await this.database.consumeCredits(userId, credits, 'åˆ›å»ºAIä»»åŠ¡');
  }

  /**
   * é€€è¿˜ç§¯åˆ†
   */
  private async refundCredits(userId: string, credits: number, reason: string): Promise<void> {
    await this.database.addCredits(userId, credits, reason);
  }

  /**
   * ç”Ÿæˆä»»åŠ¡ID
   */
  private generateTaskId(): string {
    return `task_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;
  }

  /**
   * ç”Ÿæˆä»»åŠ¡ç¼–å·
   */
  private generateTaskNo(): string {
    const date = new Date();
    const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
    const timeStr = date.toTimeString().slice(0, 8).replace(/:/g, '');
    const random = Math.random().toString(36).substring(2, 6).toUpperCase();
    return `T${dateStr}${timeStr}${random}`;
  }
}
```

## ğŸ“Š æ•°æ®åº“ä»£ç ç¤ºä¾‹

### æ•°æ®åº“æœåŠ¡

**æ–‡ä»¶**: `backend/src/services/database.ts`

```typescript
import sqlite3 from 'sqlite3';
import { open, Database } from 'sqlite';
import { Task } from './task-manager';

export class DatabaseService {
  private db: Database<sqlite3.Database, sqlite3.Statement> | null = null;

  async initialize(dbPath: string = './database.sqlite'): Promise<void> {
    this.db = await open({
      filename: dbPath,
      driver: sqlite3.Database
    });

    // åˆ›å»ºè¡¨
    await this.createTables();
    console.log('æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ');
  }

  private async createTables(): Promise<void> {
    if (!this.db) throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');

    // ç”¨æˆ·è¡¨
    await this.db.exec(`
      CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        username TEXT UNIQUE,
        password_hash TEXT,
        avatar_url TEXT,
        is_active BOOLEAN DEFAULT TRUE,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // ç”¨æˆ·ç§¯åˆ†è¡¨
    await this.db.exec(`
      CREATE TABLE IF NOT EXISTS user_credits (
        user_id TEXT PRIMARY KEY,
        credits INTEGER DEFAULT 0,
        total_earned INTEGER DEFAULT 0,
        total_spent INTEGER DEFAULT 0,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    `);

    // AIä»»åŠ¡è¡¨
    await this.db.exec(`
      CREATE TABLE IF NOT EXISTS ai_tasks (
        id TEXT PRIMARY KEY,
        task_no TEXT UNIQUE NOT NULL,
        user_id TEXT NOT NULL,
        task_type TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        ai_provider TEXT NOT NULL,
        ai_model TEXT,
        ai_task_id TEXT,
        input_files TEXT,
        input_parameters TEXT,
        prompt TEXT,
        result_urls TEXT,
        result_metadata TEXT,
        error_message TEXT,
        retry_count INTEGER DEFAULT 0,
        estimated_completion_at DATETIME,
        started_at DATETIME,
        completed_at DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    `);

    // ç§¯åˆ†äº¤æ˜“è®°å½•è¡¨
    await this.db.exec(`
      CREATE TABLE IF NOT EXISTS credit_transactions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        task_id TEXT,
        transaction_type TEXT NOT NULL,
        amount INTEGER NOT NULL,
        balance_before INTEGER NOT NULL,
        balance_after INTEGER NOT NULL,
        description TEXT,
        metadata TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
        FOREIGN KEY (task_id) REFERENCES ai_tasks(id) ON DELETE SET NULL
      )
    `);

    // åˆ›å»ºç´¢å¼•
    await this.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_ai_tasks_user_id ON ai_tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_tasks_status ON ai_tasks(status);
      CREATE INDEX IF NOT EXISTS idx_ai_tasks_created_at ON ai_tasks(created_at);
      CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_id ON credit_transactions(user_id);
    `);
  }

  // ä»»åŠ¡ç›¸å…³æ–¹æ³•
  async createTask(task: Task): Promise<void> {
    if (!this.db) throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');

    await this.db.run(`
      INSERT INTO ai_tasks (
        id, task_no, user_id, task_type, status, ai_provider,
        input_files, input_parameters, prompt, retry_count,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      task.id, task.taskNo, task.userId, task.taskType, task.status,
      task.aiProvider, JSON.stringify(task.inputFiles),
      JSON.stringify(task.inputParameters), task.prompt, task.retryCount,
      task.createdAt.toISOString(), task.updatedAt.toISOString()
    ]);
  }

  async updateTask(taskId: string, updates: Partial<Task>): Promise<void> {
    if (!this.db) throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');

    const fields = [];
    const values = [];

    for (const [key, value] of Object.entries(updates)) {
      if (value !== undefined) {
        if (key === 'inputFiles' || key === 'resultUrls' || key === 'inputParameters') {
          fields.push(`${this.camelToSnake(key)} = ?`);
          values.push(JSON.stringify(value));
        } else if (value instanceof Date) {
          fields.push(`${this.camelToSnake(key)} = ?`);
          values.push(value.toISOString());
        } else {
          fields.push(`${this.camelToSnake(key)} = ?`);
          values.push(value);
        }
      }
    }

    if (fields.length === 0) return;

    fields.push('updated_at = ?');
    values.push(new Date().toISOString());
    values.push(taskId);

    await this.db.run(
      `UPDATE ai_tasks SET ${fields.join(', ')} WHERE id = ?`,
      values
    );
  }

  async getTask(taskId: string): Promise<Task | null> {
    if (!this.db) throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');

    const row = await this.db.get(
      'SELECT * FROM ai_tasks WHERE id = ?',
      [taskId]
    );

    return row ? this.rowToTask(row) : null;
  }

  async getUserTasks(
    userId: string,
    limit: number = 20,
    offset: number = 0
  ): Promise<{ tasks: Task[]; total: number }> {
    if (!this.db) throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');

    const [rows, countRow] = await Promise.all([
      this.db.all(
        'SELECT * FROM ai_tasks WHERE user_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?',
        [userId, limit, offset]
      ),
      this.db.get(
        'SELECT COUNT(*) as count FROM ai_tasks WHERE user_id = ?',
        [userId]
      )
    ]);

    return {
      tasks: rows.map(row => this.rowToTask(row)),
      total: countRow?.count || 0
    };
  }

  // ç§¯åˆ†ç›¸å…³æ–¹æ³•
  async getUserCredits(userId: string): Promise<number> {
    if (!this.db) throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');

    const row = await this.db.get(
      'SELECT credits FROM user_credits WHERE user_id = ?',
      [userId]
    );

    return row?.credits || 0;
  }

  async addCredits(userId: string, amount: number, description: string): Promise<void> {
    if (!this.db) throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');

    await this.db.run('BEGIN TRANSACTION');
    
    try {
      // è·å–å½“å‰ç§¯åˆ†
      const currentCredits = await this.getUserCredits(userId);
      const newCredits = currentCredits + amount;

      // æ›´æ–°æˆ–æ’å…¥ç”¨æˆ·ç§¯åˆ†
      await this.db.run(`
        INSERT INTO user_credits (user_id, credits, total_earned, updated_at)
        VALUES (?, ?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
          credits = ?,
          total_earned = total_earned + ?,
          updated_at = ?
      `, [
        userId, newCredits, amount, new Date().toISOString(),
        newCredits, amount, new Date().toISOString()
      ]);

      // è®°å½•äº¤æ˜“
      await this.db.run(`
        INSERT INTO credit_transactions (
          user_id, transaction_type, amount, balance_before, balance_after, description
        ) VALUES (?, ?, ?, ?, ?, ?)
      `, [userId, 'earn', amount, currentCredits, newCredits, description]);

      await this.db.run('COMMIT');
    } catch (error) {
      await this.db.run('ROLLBACK');
      throw error;
    }
  }

  async consumeCredits(userId: string, amount: number, description: string): Promise<void> {
    if (!this.db) throw new Error('æ•°æ®åº“æœªåˆå§‹åŒ–');

    await this.db.run('BEGIN TRANSACTION');
    
    try {
      const currentCredits = await this.getUserCredits(userId);
      if (currentCredits < amount) {
        throw new Error('ç§¯åˆ†ä¸è¶³');
      }

      const newCredits = currentCredits - amount;

      await this.db.run(`
        UPDATE user_credits SET
          credits = ?,
          total_spent = total_spent + ?,
          updated_at = ?
        WHERE user_id = ?
      `, [newCredits, amount, new Date().toISOString(), userId]);

      await this.db.run(`
        INSERT INTO credit_transactions (
          user_id, transaction_type, amount, balance_before, balance_after, description
        ) VALUES (?, ?, ?, ?, ?, ?)
      `, [userId, 'spend', -amount, currentCredits, newCredits, description]);

      await this.db.run('COMMIT');
    } catch (error) {
      await this.db.run('ROLLBACK');
      throw error;
    }
  }

  // å·¥å…·æ–¹æ³•
  private rowToTask(row: any): Task {
    return {
      id: row.id,
      taskNo: row.task_no,
      userId: row.user_id,
      status: row.status,
      taskType: row.task_type,
      aiProvider: row.ai_provider,
      aiTaskId: row.ai_task_id,
      inputFiles: row.input_files ? JSON.parse(row.input_files) : [],
      inputParameters: row.input_parameters ? JSON.parse(row.input_parameters) : {},
      prompt: row.prompt,
      resultUrls: row.result_urls ? JSON.parse(row.result_urls) : undefined,
      errorMessage: row.error_message,
      retryCount: row.retry_count,
      estimatedCompletionAt: row.estimated_completion_at ? new Date(row.estimated_completion_at) : undefined,
      startedAt: row.started_at ? new Date(row.started_at) : undefined,
      completedAt: row.completed_at ? new Date(row.completed_at) : undefined,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }

  private camelToSnake(str: string): string {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
  }

  async close(): Promise<void> {
    if (this.db) {
      await this.db.close();
      this.db = null;
    }
  }
}
```

## âš™ï¸ é…ç½®æ–‡ä»¶ç¤ºä¾‹

### ç¯å¢ƒå˜é‡é…ç½®

**æ–‡ä»¶**: `.env.example`

```bash
# åº”ç”¨é…ç½®
NODE_ENV=development
PORT=3000
APP_URL=http://localhost:3000

# æ•°æ®åº“é…ç½®
DATABASE_URL=./database.sqlite

# å­˜å‚¨é…ç½® (Cloudflare R2)
STORAGE_PROVIDER=r2
R2_BUCKET_NAME=your-bucket-name
R2_ACCESS_KEY_ID=your-access-key
R2_SECRET_ACCESS_KEY=your-secret-key
R2_ENDPOINT=https://your-account-id.r2.cloudflarestorage.com
CDN_URL=https://your-cdn-domain.com

# æˆ–è€…ä½¿ç”¨ AWS S3
# STORAGE_PROVIDER=s3
# S3_BUCKET_NAME=your-s3-bucket
# S3_ACCESS_KEY_ID=your-s3-access-key
# S3_SECRET_ACCESS_KEY=your-s3-secret-key
# S3_REGION=us-east-1

# AIæœåŠ¡é…ç½®
DEFAULT_AI_PROVIDER=openai

# OpenAIé…ç½®
OPENAI_API_KEY=sk-your-openai-api-key
OPENAI_BASE_URL=https://api.openai.com/v1
OPENAI_MODEL=dall-e-3

# Stability AIé…ç½®
STABILITY_API_KEY=sk-your-stability-api-key
STABILITY_BASE_URL=https://api.stability.ai/v1

# JWTé…ç½®
JWT_SECRET=your-super-secret-jwt-key
JWT_EXPIRES_IN=7d

# é‚®ä»¶é…ç½®ï¼ˆå¯é€‰ï¼‰
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password

# æ”¯ä»˜é…ç½®ï¼ˆå¯é€‰ï¼‰
STRIPE_PUBLIC_KEY=pk_test_your-stripe-public-key
STRIPE_SECRET_KEY=sk_test_your-stripe-secret-key
STRIPE_WEBHOOK_SECRET=whsec_your-webhook-secret
```

### æ•°æ®åº“åˆå§‹åŒ–è„šæœ¬

**æ–‡ä»¶**: `scripts/init-db.sql`

```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  username TEXT UNIQUE,
  password_hash TEXT,
  avatar_url TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·ç§¯åˆ†è¡¨
CREATE TABLE IF NOT EXISTS user_credits (
  user_id TEXT PRIMARY KEY,
  credits INTEGER DEFAULT 0,
  total_earned INTEGER DEFAULT 0,
  total_spent INTEGER DEFAULT 0,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- AIä»»åŠ¡è¡¨
CREATE TABLE IF NOT EXISTS ai_tasks (
  id TEXT PRIMARY KEY,
  task_no TEXT UNIQUE NOT NULL,
  user_id TEXT NOT NULL,
  task_type TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending',
  ai_provider TEXT NOT NULL,
  ai_model TEXT,
  ai_task_id TEXT,
  input_files TEXT,
  input_parameters TEXT,
  prompt TEXT,
  result_urls TEXT,
  result_metadata TEXT,
  error_message TEXT,
  retry_count INTEGER DEFAULT 0,
  estimated_completion_at DATETIME,
  started_at DATETIME,
  completed_at DATETIME,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- ç§¯åˆ†äº¤æ˜“è®°å½•è¡¨
CREATE TABLE IF NOT EXISTS credit_transactions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  task_id TEXT,
  transaction_type TEXT NOT NULL,
  amount INTEGER NOT NULL,
  balance_before INTEGER NOT NULL,
  balance_after INTEGER NOT NULL,
  description TEXT,
  metadata TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (task_id) REFERENCES ai_tasks(id) ON DELETE SET NULL
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_ai_tasks_user_id ON ai_tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_ai_tasks_status ON ai_tasks(status);
CREATE INDEX IF NOT EXISTS idx_ai_tasks_created_at ON ai_tasks(created_at);
CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_id ON credit_transactions(user_id);

-- æ’å…¥æµ‹è¯•æ•°æ®
INSERT OR IGNORE INTO users (id, email, username) VALUES 
('user_1', 'test@example.com', 'testuser');

INSERT OR IGNORE INTO user_credits (user_id, credits, total_earned) VALUES 
('user_1', 100, 100);
```

## ğŸŒ APIè·¯ç”±ç¤ºä¾‹

### Express.js è·¯ç”±

**æ–‡ä»¶**: `backend/src/routes/tasks.ts`

```typescript
import express from 'express';
import multer from 'multer';
import { TaskManager } from '../services/task-manager';
import { createStorageService } from '../services/storage';
import { createAIClientFromEnv } from '../services/ai-client';
import { DatabaseService } from '../services/database';
import { authenticateUser } from '../middleware/auth';
import { validateRequest } from '../middleware/validation';
import { body, param, query } from 'express-validator';

const router = express.Router();

// åˆå§‹åŒ–æœåŠ¡
const storage = createStorageService();
const aiClient = createAIClientFromEnv();
const database = new DatabaseService();
const taskManager = new TaskManager(storage, aiClient, database);

// é…ç½®æ–‡ä»¶ä¸Šä¼ 
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
    files: 5
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹'));
    }
  }
});

/**
 * åˆ›å»ºAIä»»åŠ¡
 * POST /api/tasks
 */
router.post('/',
  authenticateUser,
  upload.array('files', 5),
  [
    body('taskType').isString().notEmpty().withMessage('ä»»åŠ¡ç±»å‹ä¸èƒ½ä¸ºç©º'),
    body('parameters').isObject().withMessage('å‚æ•°å¿…é¡»æ˜¯å¯¹è±¡'),
    body('credits').optional().isInt({ min: 0 }).withMessage('ç§¯åˆ†å¿…é¡»æ˜¯éè´Ÿæ•´æ•°')
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { taskType, parameters, credits = 0 } = req.body;
      const files = req.files as Express.Multer.File[];
      const userId = req.user.id;

      if (!files || files.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'è¯·ä¸Šä¼ è‡³å°‘ä¸€ä¸ªæ–‡ä»¶'
        });
      }

      // è½¬æ¢æ–‡ä»¶æ ¼å¼
      const fileData = files.map(file => ({
        buffer: file.buffer,
        name: file.originalname,
        contentType: file.mimetype
      }));

      const task = await taskManager.createTask({
        userId,
        files: fileData,
        parameters,
        taskType,
        credits: parseInt(credits)
      });

      res.json({
        success: true,
        data: task,
        message: 'ä»»åŠ¡åˆ›å»ºæˆåŠŸ'
      });
    } catch (error) {
      console.error('åˆ›å»ºä»»åŠ¡å¤±è´¥:', error);
      res.status(500).json({
        success: false,
        message: (error as Error).message || 'åˆ›å»ºä»»åŠ¡å¤±è´¥'
      });
    }
  }
);

/**
 * è·å–ä»»åŠ¡çŠ¶æ€
 * GET /api/tasks/:taskId
 */
router.get('/:taskId',
  authenticateUser,
  [
    param('taskId').isString().notEmpty().withMessage('ä»»åŠ¡IDä¸èƒ½ä¸ºç©º')
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { taskId } = req.params;
      const userId = req.user.id;

      const task = await taskManager.getTaskStatus(taskId);
      if (!task) {
        return res.status(404).json({
          success: false,
          message: 'ä»»åŠ¡ä¸å­˜åœ¨'
        });
      }

      // æ£€æŸ¥æƒé™
      if (task.userId !== userId) {
        return res.status(403).json({
          success: false,
          message: 'æ— æƒè®¿é—®æ­¤ä»»åŠ¡'
        });
      }

      res.json({
        success: true,
        data: task
      });
    } catch (error) {
      console.error('è·å–ä»»åŠ¡çŠ¶æ€å¤±è´¥:', error);
      res.status(500).json({
        success: false,
        message: 'è·å–ä»»åŠ¡çŠ¶æ€å¤±è´¥'
      });
    }
  }
);

/**
 * è·å–ç”¨æˆ·ä»»åŠ¡åˆ—è¡¨
 * GET /api/tasks
 */
router.get('/',
  authenticateUser,
  [
    query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('limitå¿…é¡»åœ¨1-100ä¹‹é—´'),
    query('offset').optional().isInt({ min: 0 }).withMessage('offsetå¿…é¡»å¤§äºç­‰äº0')
  ],
  validateRequest,
  async (req, res) => {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit as string) || 20;
      const offset = parseInt(req.query.offset as string) || 0;

      const result = await taskManager.getUserTasks(userId, limit, offset);

      res.json({
        success: true,
        data: result.tasks,
        pagination: {
          total: result.total,
          limit,
          offset,
          hasMore: offset + limit < result.total
        }
      });
    } catch (error) {
      console.error('è·å–ä»»åŠ¡åˆ—è¡¨å¤±è´¥:', error);
      res.status(500).json({
        success: false,
        message: 'è·å–ä»»åŠ¡åˆ—è¡¨å¤±è´¥'
      });
    }
  }
);

/**
 * é‡è¯•å¤±è´¥çš„ä»»åŠ¡
 * POST /api/tasks/:taskId/retry
 */
router.post('/:taskId/retry',
  authenticateUser,
  [
    param('taskId').isString().notEmpty().withMessage('ä»»åŠ¡IDä¸èƒ½ä¸ºç©º')
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { taskId } = req.params;
      const userId = req.user.id;

      // æ£€æŸ¥ä»»åŠ¡æƒé™
      const existingTask = await taskManager.getTaskStatus(taskId);
      if (!existingTask || existingTask.userId !== userId) {
        return res.status(404).json({
          success: false,
          message: 'ä»»åŠ¡ä¸å­˜åœ¨æˆ–æ— æƒè®¿é—®'
        });
      }

      const task = await taskManager.retryTask(taskId);

      res.json({
        success: true,
        data: task,
        message: 'ä»»åŠ¡é‡è¯•æˆåŠŸ'
      });
    } catch (error) {
      console.error('é‡è¯•ä»»åŠ¡å¤±è´¥:', error);
      res.status(400).json({
        success: false,
        message: (error as Error).message || 'é‡è¯•ä»»åŠ¡å¤±è´¥'
      });
    }
  }
);

export default router;
```