# 💻 AI图片生成系统 - 代码示例集合

> 这里提供了完整的代码示例，你可以直接复制使用！

## 📁 目录结构

```
你的项目/
├── frontend/          # 前端代码
├── backend/           # 后端代码
├── shared/            # 共享代码
└── docs/              # 文档
```

## 🎨 前端代码示例

### 1. 文件上传组件 (React + TypeScript)

**文件**: `frontend/src/components/FileUpload.tsx`

```typescript
import React, { useState, useCallback } from 'react';
import './FileUpload.css';

interface FileUploadProps {
  onFileSelect: (files: File[]) => void;
  maxFiles?: number;
  maxSizeMB?: number;
  acceptedTypes?: string[];
  disabled?: boolean;
}

export const FileUpload: React.FC<FileUploadProps> = ({
  onFileSelect,
  maxFiles = 1,
  maxSizeMB = 10,
  acceptedTypes = ['image/jpeg', 'image/png', 'image/webp'],
  disabled = false
}) => {
  const [dragActive, setDragActive] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
  const [errors, setErrors] = useState<string[]>([]);

  // 验证文件
  const validateFile = useCallback((file: File): string | null => {
    // 检查文件类型
    if (!acceptedTypes.includes(file.type)) {
      return `不支持的文件类型: ${file.name}`;
    }

    // 检查文件大小
    const sizeMB = file.size / (1024 * 1024);
    if (sizeMB > maxSizeMB) {
      return `文件太大: ${file.name} (${sizeMB.toFixed(1)}MB > ${maxSizeMB}MB)`;
    }

    return null;
  }, [acceptedTypes, maxSizeMB]);

  // 处理文件选择
  const handleFiles = useCallback((fileList: FileList | null) => {
    if (!fileList) return;

    const files = Array.from(fileList);
    const newErrors: string[] = [];
    const validFiles: File[] = [];

    // 检查文件数量
    if (files.length > maxFiles) {
      newErrors.push(`最多只能选择 ${maxFiles} 个文件`);
    }

    // 验证每个文件
    files.slice(0, maxFiles).forEach(file => {
      const error = validateFile(file);
      if (error) {
        newErrors.push(error);
      } else {
        validFiles.push(file);
      }
    });

    setErrors(newErrors);
    setSelectedFiles(validFiles);
    
    if (validFiles.length > 0) {
      onFileSelect(validFiles);
    }
  }, [maxFiles, validateFile, onFileSelect]);

  // 拖拽处理
  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (disabled) return;
    handleFiles(e.dataTransfer.files);
  }, [handleFiles, disabled]);

  const handleInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    handleFiles(e.target.files);
  }, [handleFiles]);

  // 移除文件
  const removeFile = useCallback((index: number) => {
    const newFiles = selectedFiles.filter((_, i) => i !== index);
    setSelectedFiles(newFiles);
    onFileSelect(newFiles);
  }, [selectedFiles, onFileSelect]);

  return (
    <div className="file-upload">
      {/* 上传区域 */}
      <div
        className={`upload-area ${
          dragActive ? 'drag-active' : ''
        } ${disabled ? 'disabled' : ''}`}
        onDragEnter={handleDrag}
        onDragLeave={handleDrag}
        onDragOver={handleDrag}
        onDrop={handleDrop}
        onClick={() => !disabled && document.getElementById('file-input')?.click()}
      >
        <input
          id="file-input"
          type="file"
          multiple={maxFiles > 1}
          accept={acceptedTypes.join(',')}
          onChange={handleInputChange}
          disabled={disabled}
          style={{ display: 'none' }}
        />
        
        <div className="upload-content">
          <div className="upload-icon">📁</div>
          <h3>选择图片文件</h3>
          <p>拖拽文件到这里或点击选择</p>
          <div className="upload-info">
            <span>支持: {acceptedTypes.map(type => type.split('/')[1].toUpperCase()).join(', ')}</span>
            <span>最大: {maxSizeMB}MB</span>
            {maxFiles > 1 && <span>最多: {maxFiles}个文件</span>}
          </div>
        </div>
      </div>

      {/* 已选文件列表 */}
      {selectedFiles.length > 0 && (
        <div className="selected-files">
          <h4>已选择的文件:</h4>
          {selectedFiles.map((file, index) => (
            <div key={index} className="file-item">
              <div className="file-info">
                <span className="file-name">{file.name}</span>
                <span className="file-size">
                  {(file.size / (1024 * 1024)).toFixed(1)}MB
                </span>
              </div>
              <button
                type="button"
                onClick={() => removeFile(index)}
                className="remove-btn"
              >
                ✕
              </button>
            </div>
          ))}
        </div>
      )}

      {/* 错误信息 */}
      {errors.length > 0 && (
        <div className="error-list">
          {errors.map((error, index) => (
            <div key={index} className="error-message">
              ⚠️ {error}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

**样式文件**: `frontend/src/components/FileUpload.css`

```css
.file-upload {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

.upload-area {
  border: 2px dashed #ccc;
  border-radius: 8px;
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  background: #fafafa;
}

.upload-area:hover {
  border-color: #007bff;
  background: #f0f8ff;
}

.upload-area.drag-active {
  border-color: #007bff;
  background: #e6f3ff;
  transform: scale(1.02);
}

.upload-area.disabled {
  opacity: 0.6;
  cursor: not-allowed;
  background: #f5f5f5;
}

.upload-content {
  pointer-events: none;
}

.upload-icon {
  font-size: 48px;
  margin-bottom: 16px;
}

.upload-content h3 {
  margin: 0 0 8px 0;
  color: #333;
  font-size: 18px;
}

.upload-content p {
  margin: 0 0 16px 0;
  color: #666;
  font-size: 14px;
}

.upload-info {
  display: flex;
  justify-content: center;
  gap: 16px;
  font-size: 12px;
  color: #999;
}

.selected-files {
  margin-top: 20px;
  padding: 16px;
  background: #f9f9f9;
  border-radius: 8px;
}

.selected-files h4 {
  margin: 0 0 12px 0;
  color: #333;
  font-size: 14px;
}

.file-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: white;
  border-radius: 4px;
  margin-bottom: 8px;
  border: 1px solid #eee;
}

.file-info {
  display: flex;
  flex-direction: column;
  flex: 1;
}

.file-name {
  font-size: 14px;
  color: #333;
  font-weight: 500;
}

.file-size {
  font-size: 12px;
  color: #666;
}

.remove-btn {
  background: #ff4757;
  color: white;
  border: none;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  cursor: pointer;
  font-size: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.remove-btn:hover {
  background: #ff3742;
}

.error-list {
  margin-top: 16px;
}

.error-message {
  padding: 8px 12px;
  background: #ffe6e6;
  border: 1px solid #ffcccc;
  border-radius: 4px;
  color: #d63031;
  font-size: 14px;
  margin-bottom: 8px;
}
```

### 2. 任务进度组件

**文件**: `frontend/src/components/TaskProgress.tsx`

```typescript
import React from 'react';
import './TaskProgress.css';

interface Task {
  id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress?: number;
  resultUrls?: string[];
  error?: string;
  createdAt: Date;
}

interface TaskProgressProps {
  tasks: Task[];
  onDownload?: (url: string) => void;
  onRetry?: (taskId: string) => void;
}

export const TaskProgress: React.FC<TaskProgressProps> = ({
  tasks,
  onDownload,
  onRetry
}) => {
  const getStatusIcon = (status: Task['status']) => {
    switch (status) {
      case 'pending': return '⏳';
      case 'processing': return '🔄';
      case 'completed': return '✅';
      case 'failed': return '❌';
      default: return '❓';
    }
  };

  const getStatusText = (status: Task['status']) => {
    switch (status) {
      case 'pending': return '等待处理';
      case 'processing': return '正在处理';
      case 'completed': return '处理完成';
      case 'failed': return '处理失败';
      default: return '未知状态';
    }
  };

  const formatTime = (date: Date) => {
    return date.toLocaleString('zh-CN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  if (tasks.length === 0) {
    return (
      <div className="task-progress empty">
        <div className="empty-state">
          <div className="empty-icon">📝</div>
          <h3>暂无任务</h3>
          <p>上传图片开始你的第一个AI处理任务吧！</p>
        </div>
      </div>
    );
  }

  return (
    <div className="task-progress">
      <h3>处理任务 ({tasks.length})</h3>
      
      <div className="task-list">
        {tasks.map((task) => (
          <div key={task.id} className={`task-item ${task.status}`}>
            <div className="task-header">
              <div className="task-status">
                <span className="status-icon">{getStatusIcon(task.status)}</span>
                <span className="status-text">{getStatusText(task.status)}</span>
              </div>
              <div className="task-time">
                {formatTime(task.createdAt)}
              </div>
            </div>

            {/* 进度条 */}
            {task.status === 'processing' && (
              <div className="progress-bar">
                <div 
                  className="progress-fill"
                  style={{ width: `${task.progress || 0}%` }}
                />
                <span className="progress-text">
                  {task.progress || 0}%
                </span>
              </div>
            )}

            {/* 错误信息 */}
            {task.status === 'failed' && task.error && (
              <div className="error-info">
                <p>错误原因: {task.error}</p>
                {onRetry && (
                  <button 
                    onClick={() => onRetry(task.id)}
                    className="retry-btn"
                  >
                    重试
                  </button>
                )}
              </div>
            )}

            {/* 结果展示 */}
            {task.status === 'completed' && task.resultUrls && (
              <div className="result-gallery">
                <h4>处理结果:</h4>
                <div className="result-images">
                  {task.resultUrls.map((url, index) => (
                    <div key={index} className="result-item">
                      <img 
                        src={url} 
                        alt={`结果 ${index + 1}`}
                        className="result-image"
                      />
                      {onDownload && (
                        <button 
                          onClick={() => onDownload(url)}
                          className="download-btn"
                        >
                          下载
                        </button>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  );
};
```

### 3. 自定义Hook - 任务轮询

**文件**: `frontend/src/hooks/useTaskPolling.ts`

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';

interface Task {
  id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress?: number;
  resultUrls?: string[];
  error?: string;
}

interface UseTaskPollingOptions {
  intervalMs?: number;        // 轮询间隔（毫秒）
  maxAttempts?: number;       // 最大轮询次数
  onTaskComplete?: (task: Task) => void;  // 任务完成回调
  onTaskFailed?: (task: Task) => void;    // 任务失败回调
}

export const useTaskPolling = (
  initialTasks: Task[] = [],
  options: UseTaskPollingOptions = {}
) => {
  const {
    intervalMs = 2000,
    maxAttempts = 150, // 5分钟
    onTaskComplete,
    onTaskFailed
  } = options;

  const [tasks, setTasks] = useState<Task[]>(initialTasks);
  const [isPolling, setIsPolling] = useState(false);
  const [attempts, setAttempts] = useState(0);
  
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const attemptsRef = useRef(0);

  // 检查任务是否完成
  const isTaskCompleted = useCallback((task: Task): boolean => {
    return task.status === 'completed' || task.status === 'failed';
  }, []);

  // 获取任务状态
  const fetchTaskStatus = useCallback(async (taskId: string): Promise<Task | null> => {
    try {
      const response = await fetch(`/api/tasks/${taskId}/status`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      console.error(`获取任务 ${taskId} 状态失败:`, error);
      return null;
    }
  }, []);

  // 更新单个任务
  const updateTask = useCallback(async (task: Task): Promise<Task> => {
    if (isTaskCompleted(task)) {
      return task; // 已完成的任务不需要更新
    }

    const updatedTask = await fetchTaskStatus(task.id);
    if (!updatedTask) {
      return task; // 获取失败，保持原状态
    }

    // 触发回调
    if (updatedTask.status === 'completed' && onTaskComplete) {
      onTaskComplete(updatedTask);
    } else if (updatedTask.status === 'failed' && onTaskFailed) {
      onTaskFailed(updatedTask);
    }

    return updatedTask;
  }, [isTaskCompleted, fetchTaskStatus, onTaskComplete, onTaskFailed]);

  // 轮询逻辑
  const pollTasks = useCallback(async () => {
    try {
      const updatedTasks = await Promise.all(
        tasks.map(updateTask)
      );
      
      setTasks(updatedTasks);
      
      // 检查是否所有任务都完成了
      const allCompleted = updatedTasks.every(isTaskCompleted);
      if (allCompleted) {
        setIsPolling(false);
        return;
      }

      // 检查是否达到最大轮询次数
      attemptsRef.current += 1;
      setAttempts(attemptsRef.current);
      
      if (attemptsRef.current >= maxAttempts) {
        console.warn('达到最大轮询次数，停止轮询');
        setIsPolling(false);
        return;
      }

    } catch (error) {
      console.error('轮询任务状态失败:', error);
    }
  }, [tasks, updateTask, isTaskCompleted, maxAttempts]);

  // 开始轮询
  const startPolling = useCallback(() => {
    if (isPolling) return;
    
    setIsPolling(true);
    attemptsRef.current = 0;
    setAttempts(0);
    
    // 立即执行一次
    pollTasks();
    
    // 设置定时器
    intervalRef.current = setInterval(pollTasks, intervalMs);
  }, [isPolling, pollTasks, intervalMs]);

  // 停止轮询
  const stopPolling = useCallback(() => {
    setIsPolling(false);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);

  // 添加新任务
  const addTask = useCallback((newTask: Task) => {
    setTasks(prev => [...prev, newTask]);
    
    // 如果有未完成的任务且没有在轮询，则开始轮询
    if (!isTaskCompleted(newTask) && !isPolling) {
      startPolling();
    }
  }, [isTaskCompleted, isPolling, startPolling]);

  // 移除任务
  const removeTask = useCallback((taskId: string) => {
    setTasks(prev => prev.filter(task => task.id !== taskId));
  }, []);

  // 清空所有任务
  const clearTasks = useCallback(() => {
    setTasks([]);
    stopPolling();
  }, [stopPolling]);

  // 组件卸载时清理
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  // 当任务列表变化时，检查是否需要开始或停止轮询
  useEffect(() => {
    const hasIncompleteTasks = tasks.some(task => !isTaskCompleted(task));
    
    if (hasIncompleteTasks && !isPolling) {
      startPolling();
    } else if (!hasIncompleteTasks && isPolling) {
      stopPolling();
    }
  }, [tasks, isPolling, isTaskCompleted, startPolling, stopPolling]);

  return {
    tasks,
    setTasks,
    isPolling,
    attempts,
    maxAttempts,
    startPolling,
    stopPolling,
    addTask,
    removeTask,
    clearTasks,
    allCompleted: tasks.every(isTaskCompleted),
    completedCount: tasks.filter(task => task.status === 'completed').length,
    failedCount: tasks.filter(task => task.status === 'failed').length,
    processingCount: tasks.filter(task => task.status === 'processing').length
  };
};
```

## 🔧 后端代码示例

### 1. 文件存储服务

**文件**: `backend/src/services/storage.ts`

```typescript
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import crypto from 'crypto';
import path from 'path';

export interface StorageConfig {
  provider: 'r2' | 's3';
  bucket: string;
  region?: string;
  accessKeyId: string;
  secretAccessKey: string;
  endpoint?: string;
  cdnUrl?: string;
}

export interface UploadResult {
  key: string;
  url: string;
  size: number;
  contentType: string;
}

export class StorageService {
  private client: S3Client;
  private config: StorageConfig;

  constructor(config: StorageConfig) {
    this.config = config;
    this.client = new S3Client({
      region: config.region || 'auto',
      credentials: {
        accessKeyId: config.accessKeyId,
        secretAccessKey: config.secretAccessKey,
      },
      endpoint: config.endpoint,
    });
  }

  /**
   * 上传文件到存储服务
   */
  async uploadFile(
    file: Buffer | Uint8Array,
    key: string,
    contentType: string = 'application/octet-stream'
  ): Promise<UploadResult> {
    try {
      const command = new PutObjectCommand({
        Bucket: this.config.bucket,
        Key: key,
        Body: file,
        ContentType: contentType,
      });

      await this.client.send(command);

      return {
        key,
        url: this.getPublicUrl(key),
        size: file.length,
        contentType,
      };
    } catch (error) {
      console.error('文件上传失败:', error);
      throw new Error(`文件上传失败: ${(error as Error).message}`);
    }
  }

  /**
   * 从URL下载文件并上传到存储
   */
  async downloadAndUpload(
    sourceUrl: string,
    destinationKey: string
  ): Promise<UploadResult> {
    try {
      console.log(`开始下载文件: ${sourceUrl}`);
      
      const response = await fetch(sourceUrl);
      if (!response.ok) {
        throw new Error(`下载失败: ${response.status} ${response.statusText}`);
      }

      const arrayBuffer = await response.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);
      const contentType = response.headers.get('content-type') || 'application/octet-stream';

      console.log(`文件下载完成，大小: ${buffer.length} bytes`);
      
      return await this.uploadFile(buffer, destinationKey, contentType);
    } catch (error) {
      console.error('下载并上传文件失败:', error);
      throw new Error(`下载并上传文件失败: ${(error as Error).message}`);
    }
  }

  /**
   * 生成公共访问URL
   */
  getPublicUrl(key: string): string {
    if (this.config.cdnUrl) {
      return `${this.config.cdnUrl}/${key}`;
    }
    
    if (this.config.provider === 'r2') {
      return `https://${this.config.bucket}.r2.cloudflarestorage.com/${key}`;
    }
    
    return `https://${this.config.bucket}.s3.${this.config.region}.amazonaws.com/${key}`;
  }

  /**
   * 生成预签名上传URL
   */
  async getPresignedUploadUrl(
    key: string,
    contentType: string,
    expiresIn: number = 3600
  ): Promise<string> {
    const command = new PutObjectCommand({
      Bucket: this.config.bucket,
      Key: key,
      ContentType: contentType,
    });

    return getSignedUrl(this.client, command, { expiresIn });
  }

  /**
   * 生成唯一文件名
   */
  generateUniqueKey(originalName: string, folder: string = ''): string {
    const timestamp = Date.now();
    const random = crypto.randomBytes(4).toString('hex');
    const extension = path.extname(originalName);
    const baseName = path.basename(originalName, extension);
    
    // 清理文件名，移除特殊字符
    const cleanBaseName = baseName.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_');
    
    const fileName = `${timestamp}_${random}_${cleanBaseName}${extension}`;
    return folder ? `${folder}/${fileName}` : fileName;
  }

  /**
   * 批量上传文件
   */
  async uploadFiles(
    files: Array<{ buffer: Buffer; name: string; contentType: string }>,
    folder: string = 'uploads'
  ): Promise<UploadResult[]> {
    const uploadPromises = files.map(file => {
      const key = this.generateUniqueKey(file.name, folder);
      return this.uploadFile(file.buffer, key, file.contentType);
    });

    return Promise.all(uploadPromises);
  }

  /**
   * 删除文件
   */
  async deleteFile(key: string): Promise<void> {
    try {
      const command = new DeleteObjectCommand({
        Bucket: this.config.bucket,
        Key: key,
      });

      await this.client.send(command);
      console.log(`文件删除成功: ${key}`);
    } catch (error) {
      console.error('文件删除失败:', error);
      throw new Error(`文件删除失败: ${(error as Error).message}`);
    }
  }
}

// 导出配置工厂函数
export function createStorageService(): StorageService {
  const config: StorageConfig = {
    provider: (process.env.STORAGE_PROVIDER as 'r2' | 's3') || 'r2',
    bucket: process.env.R2_BUCKET_NAME || process.env.S3_BUCKET_NAME || '',
    accessKeyId: process.env.R2_ACCESS_KEY_ID || process.env.S3_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY || process.env.S3_SECRET_ACCESS_KEY || '',
    endpoint: process.env.R2_ENDPOINT,
    region: process.env.S3_REGION,
    cdnUrl: process.env.CDN_URL,
  };

  if (!config.bucket || !config.accessKeyId || !config.secretAccessKey) {
    throw new Error('存储服务配置不完整，请检查环境变量');
  }

  return new StorageService(config);
}
```

### 2. AI客户端服务

**文件**: `backend/src/services/ai-client.ts`

```typescript
export interface AITaskRequest {
  inputUrls: string[];
  prompt: string;
  parameters: Record<string, any>;
}

export interface AITaskResponse {
  taskId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress?: number;
  resultUrls?: string[];
  error?: string;
  estimatedTime?: number;
}

export interface AIClientConfig {
  provider: 'openai' | 'stability' | 'custom';
  apiKey: string;
  baseUrl?: string;
  model?: string;
}

export abstract class BaseAIClient {
  protected config: AIClientConfig;

  constructor(config: AIClientConfig) {
    this.config = config;
  }

  abstract createTask(request: AITaskRequest): Promise<AITaskResponse>;
  abstract getTaskStatus(taskId: string): Promise<AITaskResponse>;
  abstract cancelTask(taskId: string): Promise<void>;
}

/**
 * OpenAI客户端实现
 */
export class OpenAIClient extends BaseAIClient {
  private apiKey: string;
  private baseUrl: string;

  constructor(config: AIClientConfig) {
    super(config);
    this.apiKey = config.apiKey;
    this.baseUrl = config.baseUrl || 'https://api.openai.com/v1';
  }

  async createTask(request: AITaskRequest): Promise<AITaskResponse> {
    try {
      const response = await fetch(`${this.baseUrl}/images/generations`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: this.config.model || 'dall-e-3',
          prompt: request.prompt,
          n: request.parameters.variants || 1,
          size: request.parameters.size || '1024x1024',
          quality: request.parameters.quality || 'standard',
          response_format: 'url',
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(`OpenAI API错误: ${error.error?.message || response.statusText}`);
      }

      const data = await response.json();
      const taskId = `openai_${Date.now()}_${Math.random().toString(36).substring(2)}`;

      return {
        taskId,
        status: 'completed',
        resultUrls: data.data.map((item: any) => item.url),
      };
    } catch (error) {
      console.error('OpenAI任务创建失败:', error);
      throw error;
    }
  }

  async getTaskStatus(taskId: string): Promise<AITaskResponse> {
    // OpenAI的图片生成是同步的，所以这里直接返回完成状态
    return {
      taskId,
      status: 'completed',
    };
  }

  async cancelTask(taskId: string): Promise<void> {
    // OpenAI的图片生成无法取消
    throw new Error('OpenAI任务无法取消');
  }
}

/**
 * Stability AI客户端实现
 */
export class StabilityAIClient extends BaseAIClient {
  private apiKey: string;
  private baseUrl: string;

  constructor(config: AIClientConfig) {
    super(config);
    this.apiKey = config.apiKey;
    this.baseUrl = config.baseUrl || 'https://api.stability.ai/v1';
  }

  async createTask(request: AITaskRequest): Promise<AITaskResponse> {
    try {
      const formData = new FormData();
      formData.append('text_prompts[0][text]', request.prompt);
      formData.append('text_prompts[0][weight]', '1');
      formData.append('cfg_scale', request.parameters.cfgScale || '7');
      formData.append('height', request.parameters.height || '1024');
      formData.append('width', request.parameters.width || '1024');
      formData.append('samples', request.parameters.variants || '1');
      formData.append('steps', request.parameters.steps || '30');

      const response = await fetch(`${this.baseUrl}/generation/stable-diffusion-xl-1024-v1-0/text-to-image`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: formData,
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Stability AI错误: ${error.message || response.statusText}`);
      }

      const data = await response.json();
      const taskId = `stability_${Date.now()}_${Math.random().toString(36).substring(2)}`;

      // 将base64图片转换为URL（需要上传到存储服务）
      const resultUrls = await Promise.all(
        data.artifacts.map(async (artifact: any, index: number) => {
          const buffer = Buffer.from(artifact.base64, 'base64');
          // 这里需要上传到存储服务，返回URL
          // 实际实现中需要注入存储服务
          return `data:image/png;base64,${artifact.base64}`;
        })
      );

      return {
        taskId,
        status: 'completed',
        resultUrls,
      };
    } catch (error) {
      console.error('Stability AI任务创建失败:', error);
      throw error;
    }
  }

  async getTaskStatus(taskId: string): Promise<AITaskResponse> {
    return {
      taskId,
      status: 'completed',
    };
  }

  async cancelTask(taskId: string): Promise<void> {
    throw new Error('Stability AI任务无法取消');
  }
}

/**
 * AI客户端工厂
 */
export function createAIClient(config: AIClientConfig): BaseAIClient {
  switch (config.provider) {
    case 'openai':
      return new OpenAIClient(config);
    case 'stability':
      return new StabilityAIClient(config);
    default:
      throw new Error(`不支持的AI提供商: ${config.provider}`);
  }
}

/**
 * 从环境变量创建AI客户端
 */
export function createAIClientFromEnv(): BaseAIClient {
  const provider = (process.env.DEFAULT_AI_PROVIDER as any) || 'openai';
  
  const configs = {
    openai: {
      provider: 'openai' as const,
      apiKey: process.env.OPENAI_API_KEY || '',
      baseUrl: process.env.OPENAI_BASE_URL,
      model: process.env.OPENAI_MODEL,
    },
    stability: {
      provider: 'stability' as const,
      apiKey: process.env.STABILITY_API_KEY || '',
      baseUrl: process.env.STABILITY_BASE_URL,
    },
  };

  const config = configs[provider];
  if (!config || !config.apiKey) {
    throw new Error(`AI服务配置不完整: ${provider}`);
  }

  return createAIClient(config);
}
```

### 3. 任务管理服务

**文件**: `backend/src/services/task-manager.ts`

```typescript
import { StorageService } from './storage';
import { BaseAIClient } from './ai-client';
import { DatabaseService } from './database';
import crypto from 'crypto';

export interface CreateTaskOptions {
  userId: string;
  files: Array<{ buffer: Buffer; name: string; contentType: string }>;
  parameters: Record<string, any>;
  taskType: string;
  credits?: number;
}

export interface Task {
  id: string;
  taskNo: string;
  userId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  taskType: string;
  aiProvider: string;
  aiTaskId?: string;
  inputFiles: string[];
  inputParameters: Record<string, any>;
  prompt?: string;
  resultUrls?: string[];
  errorMessage?: string;
  retryCount: number;
  estimatedCompletionAt?: Date;
  startedAt?: Date;
  completedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

export class TaskManager {
  constructor(
    private storage: StorageService,
    private aiClient: BaseAIClient,
    private database: DatabaseService
  ) {}

  /**
   * 创建新的AI任务
   */
  async createTask(options: CreateTaskOptions): Promise<Task> {
    const { userId, files, parameters, taskType, credits = 0 } = options;

    // 1. 验证用户积分
    if (credits > 0) {
      await this.validateAndConsumeCredits(userId, credits);
    }

    try {
      // 2. 上传输入文件
      console.log(`开始上传 ${files.length} 个文件`);
      const uploadResults = await this.storage.uploadFiles(files, 'input');
      const inputFiles = uploadResults.map(result => result.url);
      console.log('文件上传完成:', inputFiles);

      // 3. 生成提示词
      const prompt = this.buildPrompt(taskType, parameters);
      console.log('生成的提示词:', prompt);

      // 4. 创建数据库记录
      const task: Task = {
        id: this.generateTaskId(),
        taskNo: this.generateTaskNo(),
        userId,
        status: 'pending',
        taskType,
        aiProvider: 'openai', // 可以根据配置动态设置
        inputFiles,
        inputParameters: parameters,
        prompt,
        retryCount: 0,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      await this.database.createTask(task);
      console.log('任务创建成功:', task.id);

      // 5. 异步提交到AI服务
      this.submitToAI(task).catch(error => {
        console.error('提交AI任务失败:', error);
        this.handleTaskError(task.id, error.message);
      });

      return task;
    } catch (error) {
      // 处理失败，退还积分
      if (credits > 0) {
        await this.refundCredits(userId, credits, '任务创建失败');
      }
      throw error;
    }
  }

  /**
   * 提交任务到AI服务
   */
  private async submitToAI(task: Task): Promise<void> {
    try {
      // 更新任务状态为处理中
      await this.database.updateTask(task.id, {
        status: 'processing',
        startedAt: new Date(),
        updatedAt: new Date(),
      });

      // 调用AI服务
      const aiResult = await this.aiClient.createTask({
        inputUrls: task.inputFiles,
        prompt: task.prompt || '',
        parameters: task.inputParameters,
      });

      // 更新AI任务ID
      await this.database.updateTask(task.id, {
        aiTaskId: aiResult.taskId,
        updatedAt: new Date(),
      });

      // 如果AI服务直接返回结果（同步处理）
      if (aiResult.status === 'completed' && aiResult.resultUrls) {
        await this.handleTaskCompletion(task.id, aiResult.resultUrls);
      }
    } catch (error) {
      await this.handleTaskError(task.id, (error as Error).message);
      throw error;
    }
  }

  /**
   * 处理任务完成
   */
  private async handleTaskCompletion(taskId: string, resultUrls: string[]): Promise<void> {
    try {
      // 下载结果文件到我们的存储
      const downloadPromises = resultUrls.map(async (url, index) => {
        const key = this.storage.generateUniqueKey(`result_${index}.png`, 'output');
        const result = await this.storage.downloadAndUpload(url, key);
        return result.url;
      });

      const finalResultUrls = await Promise.all(downloadPromises);

      // 更新任务状态
      await this.database.updateTask(taskId, {
        status: 'completed',
        resultUrls: finalResultUrls,
        completedAt: new Date(),
        updatedAt: new Date(),
      });

      console.log(`任务 ${taskId} 完成，结果:`, finalResultUrls);
    } catch (error) {
      console.error(`处理任务完成失败 ${taskId}:`, error);
      await this.handleTaskError(taskId, `结果处理失败: ${(error as Error).message}`);
    }
  }

  /**
   * 处理任务错误
   */
  private async handleTaskError(taskId: string, errorMessage: string): Promise<void> {
    try {
      const task = await this.database.getTask(taskId);
      if (!task) return;

      // 退还积分
      const credits = task.inputParameters.credits || 0;
      if (credits > 0) {
        await this.refundCredits(task.userId, credits, '任务失败退款');
      }

      // 更新任务状态
      await this.database.updateTask(taskId, {
        status: 'failed',
        errorMessage,
        completedAt: new Date(),
        updatedAt: new Date(),
      });

      console.log(`任务 ${taskId} 失败:`, errorMessage);
    } catch (error) {
      console.error(`处理任务错误失败 ${taskId}:`, error);
    }
  }

  /**
   * 获取任务状态
   */
  async getTaskStatus(taskId: string): Promise<Task | null> {
    const task = await this.database.getTask(taskId);
    if (!task) return null;

    // 如果任务还在处理中，查询AI服务状态
    if (task.status === 'processing' && task.aiTaskId) {
      try {
        const aiStatus = await this.aiClient.getTaskStatus(task.aiTaskId);
        
        if (aiStatus.status === 'completed' && aiStatus.resultUrls) {
          await this.handleTaskCompletion(task.id, aiStatus.resultUrls);
          return await this.database.getTask(taskId); // 返回更新后的任务
        } else if (aiStatus.status === 'failed') {
          await this.handleTaskError(task.id, aiStatus.error || '未知错误');
          return await this.database.getTask(taskId);
        }
      } catch (error) {
        console.error('查询AI任务状态失败:', error);
      }
    }

    return task;
  }

  /**
   * 获取用户任务列表
   */
  async getUserTasks(
    userId: string,
    limit: number = 20,
    offset: number = 0
  ): Promise<{ tasks: Task[]; total: number }> {
    return this.database.getUserTasks(userId, limit, offset);
  }

  /**
   * 重试失败的任务
   */
  async retryTask(taskId: string): Promise<Task> {
    const task = await this.database.getTask(taskId);
    if (!task) {
      throw new Error('任务不存在');
    }

    if (task.status !== 'failed') {
      throw new Error('只能重试失败的任务');
    }

    if (task.retryCount >= 3) {
      throw new Error('重试次数已达上限');
    }

    // 重置任务状态
    const updatedTask = {
      ...task,
      status: 'pending' as const,
      errorMessage: undefined,
      retryCount: task.retryCount + 1,
      updatedAt: new Date(),
    };

    await this.database.updateTask(taskId, updatedTask);

    // 重新提交到AI服务
    this.submitToAI(updatedTask).catch(error => {
      console.error('重试任务失败:', error);
      this.handleTaskError(taskId, error.message);
    });

    return updatedTask;
  }

  /**
   * 构建提示词
   */
  private buildPrompt(taskType: string, parameters: Record<string, any>): string {
    // 这里可以根据不同的任务类型构建不同的提示词
    switch (taskType) {
      case 'style_transfer':
        return `Transform the image with ${parameters.style} style, maintaining the original composition and subject.`;
      case 'background_removal':
        return 'Remove the background from the image, keeping only the main subject.';
      case 'color_enhancement':
        return `Enhance the colors in the image with ${parameters.enhancement} effect.`;
      default:
        return parameters.prompt || 'Process the image according to the specified parameters.';
    }
  }

  /**
   * 验证并消费积分
   */
  private async validateAndConsumeCredits(userId: string, credits: number): Promise<void> {
    const userCredits = await this.database.getUserCredits(userId);
    if (userCredits < credits) {
      throw new Error(`积分不足，需要 ${credits} 积分，当前只有 ${userCredits} 积分`);
    }

    await this.database.consumeCredits(userId, credits, '创建AI任务');
  }

  /**
   * 退还积分
   */
  private async refundCredits(userId: string, credits: number, reason: string): Promise<void> {
    await this.database.addCredits(userId, credits, reason);
  }

  /**
   * 生成任务ID
   */
  private generateTaskId(): string {
    return `task_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;
  }

  /**
   * 生成任务编号
   */
  private generateTaskNo(): string {
    const date = new Date();
    const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
    const timeStr = date.toTimeString().slice(0, 8).replace(/:/g, '');
    const random = Math.random().toString(36).substring(2, 6).toUpperCase();
    return `T${dateStr}${timeStr}${random}`;
  }
}
```

## 📊 数据库代码示例

### 数据库服务

**文件**: `backend/src/services/database.ts`

```typescript
import sqlite3 from 'sqlite3';
import { open, Database } from 'sqlite';
import { Task } from './task-manager';

export class DatabaseService {
  private db: Database<sqlite3.Database, sqlite3.Statement> | null = null;

  async initialize(dbPath: string = './database.sqlite'): Promise<void> {
    this.db = await open({
      filename: dbPath,
      driver: sqlite3.Database
    });

    // 创建表
    await this.createTables();
    console.log('数据库初始化完成');
  }

  private async createTables(): Promise<void> {
    if (!this.db) throw new Error('数据库未初始化');

    // 用户表
    await this.db.exec(`
      CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        username TEXT UNIQUE,
        password_hash TEXT,
        avatar_url TEXT,
        is_active BOOLEAN DEFAULT TRUE,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // 用户积分表
    await this.db.exec(`
      CREATE TABLE IF NOT EXISTS user_credits (
        user_id TEXT PRIMARY KEY,
        credits INTEGER DEFAULT 0,
        total_earned INTEGER DEFAULT 0,
        total_spent INTEGER DEFAULT 0,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    `);

    // AI任务表
    await this.db.exec(`
      CREATE TABLE IF NOT EXISTS ai_tasks (
        id TEXT PRIMARY KEY,
        task_no TEXT UNIQUE NOT NULL,
        user_id TEXT NOT NULL,
        task_type TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        ai_provider TEXT NOT NULL,
        ai_model TEXT,
        ai_task_id TEXT,
        input_files TEXT,
        input_parameters TEXT,
        prompt TEXT,
        result_urls TEXT,
        result_metadata TEXT,
        error_message TEXT,
        retry_count INTEGER DEFAULT 0,
        estimated_completion_at DATETIME,
        started_at DATETIME,
        completed_at DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    `);

    // 积分交易记录表
    await this.db.exec(`
      CREATE TABLE IF NOT EXISTS credit_transactions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        task_id TEXT,
        transaction_type TEXT NOT NULL,
        amount INTEGER NOT NULL,
        balance_before INTEGER NOT NULL,
        balance_after INTEGER NOT NULL,
        description TEXT,
        metadata TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
        FOREIGN KEY (task_id) REFERENCES ai_tasks(id) ON DELETE SET NULL
      )
    `);

    // 创建索引
    await this.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_ai_tasks_user_id ON ai_tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_tasks_status ON ai_tasks(status);
      CREATE INDEX IF NOT EXISTS idx_ai_tasks_created_at ON ai_tasks(created_at);
      CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_id ON credit_transactions(user_id);
    `);
  }

  // 任务相关方法
  async createTask(task: Task): Promise<void> {
    if (!this.db) throw new Error('数据库未初始化');

    await this.db.run(`
      INSERT INTO ai_tasks (
        id, task_no, user_id, task_type, status, ai_provider,
        input_files, input_parameters, prompt, retry_count,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      task.id, task.taskNo, task.userId, task.taskType, task.status,
      task.aiProvider, JSON.stringify(task.inputFiles),
      JSON.stringify(task.inputParameters), task.prompt, task.retryCount,
      task.createdAt.toISOString(), task.updatedAt.toISOString()
    ]);
  }

  async updateTask(taskId: string, updates: Partial<Task>): Promise<void> {
    if (!this.db) throw new Error('数据库未初始化');

    const fields = [];
    const values = [];

    for (const [key, value] of Object.entries(updates)) {
      if (value !== undefined) {
        if (key === 'inputFiles' || key === 'resultUrls' || key === 'inputParameters') {
          fields.push(`${this.camelToSnake(key)} = ?`);
          values.push(JSON.stringify(value));
        } else if (value instanceof Date) {
          fields.push(`${this.camelToSnake(key)} = ?`);
          values.push(value.toISOString());
        } else {
          fields.push(`${this.camelToSnake(key)} = ?`);
          values.push(value);
        }
      }
    }

    if (fields.length === 0) return;

    fields.push('updated_at = ?');
    values.push(new Date().toISOString());
    values.push(taskId);

    await this.db.run(
      `UPDATE ai_tasks SET ${fields.join(', ')} WHERE id = ?`,
      values
    );
  }

  async getTask(taskId: string): Promise<Task | null> {
    if (!this.db) throw new Error('数据库未初始化');

    const row = await this.db.get(
      'SELECT * FROM ai_tasks WHERE id = ?',
      [taskId]
    );

    return row ? this.rowToTask(row) : null;
  }

  async getUserTasks(
    userId: string,
    limit: number = 20,
    offset: number = 0
  ): Promise<{ tasks: Task[]; total: number }> {
    if (!this.db) throw new Error('数据库未初始化');

    const [rows, countRow] = await Promise.all([
      this.db.all(
        'SELECT * FROM ai_tasks WHERE user_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?',
        [userId, limit, offset]
      ),
      this.db.get(
        'SELECT COUNT(*) as count FROM ai_tasks WHERE user_id = ?',
        [userId]
      )
    ]);

    return {
      tasks: rows.map(row => this.rowToTask(row)),
      total: countRow?.count || 0
    };
  }

  // 积分相关方法
  async getUserCredits(userId: string): Promise<number> {
    if (!this.db) throw new Error('数据库未初始化');

    const row = await this.db.get(
      'SELECT credits FROM user_credits WHERE user_id = ?',
      [userId]
    );

    return row?.credits || 0;
  }

  async addCredits(userId: string, amount: number, description: string): Promise<void> {
    if (!this.db) throw new Error('数据库未初始化');

    await this.db.run('BEGIN TRANSACTION');
    
    try {
      // 获取当前积分
      const currentCredits = await this.getUserCredits(userId);
      const newCredits = currentCredits + amount;

      // 更新或插入用户积分
      await this.db.run(`
        INSERT INTO user_credits (user_id, credits, total_earned, updated_at)
        VALUES (?, ?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
          credits = ?,
          total_earned = total_earned + ?,
          updated_at = ?
      `, [
        userId, newCredits, amount, new Date().toISOString(),
        newCredits, amount, new Date().toISOString()
      ]);

      // 记录交易
      await this.db.run(`
        INSERT INTO credit_transactions (
          user_id, transaction_type, amount, balance_before, balance_after, description
        ) VALUES (?, ?, ?, ?, ?, ?)
      `, [userId, 'earn', amount, currentCredits, newCredits, description]);

      await this.db.run('COMMIT');
    } catch (error) {
      await this.db.run('ROLLBACK');
      throw error;
    }
  }

  async consumeCredits(userId: string, amount: number, description: string): Promise<void> {
    if (!this.db) throw new Error('数据库未初始化');

    await this.db.run('BEGIN TRANSACTION');
    
    try {
      const currentCredits = await this.getUserCredits(userId);
      if (currentCredits < amount) {
        throw new Error('积分不足');
      }

      const newCredits = currentCredits - amount;

      await this.db.run(`
        UPDATE user_credits SET
          credits = ?,
          total_spent = total_spent + ?,
          updated_at = ?
        WHERE user_id = ?
      `, [newCredits, amount, new Date().toISOString(), userId]);

      await this.db.run(`
        INSERT INTO credit_transactions (
          user_id, transaction_type, amount, balance_before, balance_after, description
        ) VALUES (?, ?, ?, ?, ?, ?)
      `, [userId, 'spend', -amount, currentCredits, newCredits, description]);

      await this.db.run('COMMIT');
    } catch (error) {
      await this.db.run('ROLLBACK');
      throw error;
    }
  }

  // 工具方法
  private rowToTask(row: any): Task {
    return {
      id: row.id,
      taskNo: row.task_no,
      userId: row.user_id,
      status: row.status,
      taskType: row.task_type,
      aiProvider: row.ai_provider,
      aiTaskId: row.ai_task_id,
      inputFiles: row.input_files ? JSON.parse(row.input_files) : [],
      inputParameters: row.input_parameters ? JSON.parse(row.input_parameters) : {},
      prompt: row.prompt,
      resultUrls: row.result_urls ? JSON.parse(row.result_urls) : undefined,
      errorMessage: row.error_message,
      retryCount: row.retry_count,
      estimatedCompletionAt: row.estimated_completion_at ? new Date(row.estimated_completion_at) : undefined,
      startedAt: row.started_at ? new Date(row.started_at) : undefined,
      completedAt: row.completed_at ? new Date(row.completed_at) : undefined,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }

  private camelToSnake(str: string): string {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
  }

  async close(): Promise<void> {
    if (this.db) {
      await this.db.close();
      this.db = null;
    }
  }
}
```

## ⚙️ 配置文件示例

### 环境变量配置

**文件**: `.env.example`

```bash
# 应用配置
NODE_ENV=development
PORT=3000
APP_URL=http://localhost:3000

# 数据库配置
DATABASE_URL=./database.sqlite

# 存储配置 (Cloudflare R2)
STORAGE_PROVIDER=r2
R2_BUCKET_NAME=your-bucket-name
R2_ACCESS_KEY_ID=your-access-key
R2_SECRET_ACCESS_KEY=your-secret-key
R2_ENDPOINT=https://your-account-id.r2.cloudflarestorage.com
CDN_URL=https://your-cdn-domain.com

# 或者使用 AWS S3
# STORAGE_PROVIDER=s3
# S3_BUCKET_NAME=your-s3-bucket
# S3_ACCESS_KEY_ID=your-s3-access-key
# S3_SECRET_ACCESS_KEY=your-s3-secret-key
# S3_REGION=us-east-1

# AI服务配置
DEFAULT_AI_PROVIDER=openai

# OpenAI配置
OPENAI_API_KEY=sk-your-openai-api-key
OPENAI_BASE_URL=https://api.openai.com/v1
OPENAI_MODEL=dall-e-3

# Stability AI配置
STABILITY_API_KEY=sk-your-stability-api-key
STABILITY_BASE_URL=https://api.stability.ai/v1

# JWT配置
JWT_SECRET=your-super-secret-jwt-key
JWT_EXPIRES_IN=7d

# 邮件配置（可选）
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password

# 支付配置（可选）
STRIPE_PUBLIC_KEY=pk_test_your-stripe-public-key
STRIPE_SECRET_KEY=sk_test_your-stripe-secret-key
STRIPE_WEBHOOK_SECRET=whsec_your-webhook-secret
```

### 数据库初始化脚本

**文件**: `scripts/init-db.sql`

```sql
-- 用户表
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  username TEXT UNIQUE,
  password_hash TEXT,
  avatar_url TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 用户积分表
CREATE TABLE IF NOT EXISTS user_credits (
  user_id TEXT PRIMARY KEY,
  credits INTEGER DEFAULT 0,
  total_earned INTEGER DEFAULT 0,
  total_spent INTEGER DEFAULT 0,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- AI任务表
CREATE TABLE IF NOT EXISTS ai_tasks (
  id TEXT PRIMARY KEY,
  task_no TEXT UNIQUE NOT NULL,
  user_id TEXT NOT NULL,
  task_type TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending',
  ai_provider TEXT NOT NULL,
  ai_model TEXT,
  ai_task_id TEXT,
  input_files TEXT,
  input_parameters TEXT,
  prompt TEXT,
  result_urls TEXT,
  result_metadata TEXT,
  error_message TEXT,
  retry_count INTEGER DEFAULT 0,
  estimated_completion_at DATETIME,
  started_at DATETIME,
  completed_at DATETIME,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 积分交易记录表
CREATE TABLE IF NOT EXISTS credit_transactions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  task_id TEXT,
  transaction_type TEXT NOT NULL,
  amount INTEGER NOT NULL,
  balance_before INTEGER NOT NULL,
  balance_after INTEGER NOT NULL,
  description TEXT,
  metadata TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (task_id) REFERENCES ai_tasks(id) ON DELETE SET NULL
);

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_ai_tasks_user_id ON ai_tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_ai_tasks_status ON ai_tasks(status);
CREATE INDEX IF NOT EXISTS idx_ai_tasks_created_at ON ai_tasks(created_at);
CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_id ON credit_transactions(user_id);

-- 插入测试数据
INSERT OR IGNORE INTO users (id, email, username) VALUES 
('user_1', 'test@example.com', 'testuser');

INSERT OR IGNORE INTO user_credits (user_id, credits, total_earned) VALUES 
('user_1', 100, 100);
```

## 🌐 API路由示例

### Express.js 路由

**文件**: `backend/src/routes/tasks.ts`

```typescript
import express from 'express';
import multer from 'multer';
import { TaskManager } from '../services/task-manager';
import { createStorageService } from '../services/storage';
import { createAIClientFromEnv } from '../services/ai-client';
import { DatabaseService } from '../services/database';
import { authenticateUser } from '../middleware/auth';
import { validateRequest } from '../middleware/validation';
import { body, param, query } from 'express-validator';

const router = express.Router();

// 初始化服务
const storage = createStorageService();
const aiClient = createAIClientFromEnv();
const database = new DatabaseService();
const taskManager = new TaskManager(storage, aiClient, database);

// 配置文件上传
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
    files: 5
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('不支持的文件类型'));
    }
  }
});

/**
 * 创建AI任务
 * POST /api/tasks
 */
router.post('/',
  authenticateUser,
  upload.array('files', 5),
  [
    body('taskType').isString().notEmpty().withMessage('任务类型不能为空'),
    body('parameters').isObject().withMessage('参数必须是对象'),
    body('credits').optional().isInt({ min: 0 }).withMessage('积分必须是非负整数')
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { taskType, parameters, credits = 0 } = req.body;
      const files = req.files as Express.Multer.File[];
      const userId = req.user.id;

      if (!files || files.length === 0) {
        return res.status(400).json({
          success: false,
          message: '请上传至少一个文件'
        });
      }

      // 转换文件格式
      const fileData = files.map(file => ({
        buffer: file.buffer,
        name: file.originalname,
        contentType: file.mimetype
      }));

      const task = await taskManager.createTask({
        userId,
        files: fileData,
        parameters,
        taskType,
        credits: parseInt(credits)
      });

      res.json({
        success: true,
        data: task,
        message: '任务创建成功'
      });
    } catch (error) {
      console.error('创建任务失败:', error);
      res.status(500).json({
        success: false,
        message: (error as Error).message || '创建任务失败'
      });
    }
  }
);

/**
 * 获取任务状态
 * GET /api/tasks/:taskId
 */
router.get('/:taskId',
  authenticateUser,
  [
    param('taskId').isString().notEmpty().withMessage('任务ID不能为空')
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { taskId } = req.params;
      const userId = req.user.id;

      const task = await taskManager.getTaskStatus(taskId);
      if (!task) {
        return res.status(404).json({
          success: false,
          message: '任务不存在'
        });
      }

      // 检查权限
      if (task.userId !== userId) {
        return res.status(403).json({
          success: false,
          message: '无权访问此任务'
        });
      }

      res.json({
        success: true,
        data: task
      });
    } catch (error) {
      console.error('获取任务状态失败:', error);
      res.status(500).json({
        success: false,
        message: '获取任务状态失败'
      });
    }
  }
);

/**
 * 获取用户任务列表
 * GET /api/tasks
 */
router.get('/',
  authenticateUser,
  [
    query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('limit必须在1-100之间'),
    query('offset').optional().isInt({ min: 0 }).withMessage('offset必须大于等于0')
  ],
  validateRequest,
  async (req, res) => {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit as string) || 20;
      const offset = parseInt(req.query.offset as string) || 0;

      const result = await taskManager.getUserTasks(userId, limit, offset);

      res.json({
        success: true,
        data: result.tasks,
        pagination: {
          total: result.total,
          limit,
          offset,
          hasMore: offset + limit < result.total
        }
      });
    } catch (error) {
      console.error('获取任务列表失败:', error);
      res.status(500).json({
        success: false,
        message: '获取任务列表失败'
      });
    }
  }
);

/**
 * 重试失败的任务
 * POST /api/tasks/:taskId/retry
 */
router.post('/:taskId/retry',
  authenticateUser,
  [
    param('taskId').isString().notEmpty().withMessage('任务ID不能为空')
  ],
  validateRequest,
  async (req, res) => {
    try {
      const { taskId } = req.params;
      const userId = req.user.id;

      // 检查任务权限
      const existingTask = await taskManager.getTaskStatus(taskId);
      if (!existingTask || existingTask.userId !== userId) {
        return res.status(404).json({
          success: false,
          message: '任务不存在或无权访问'
        });
      }

      const task = await taskManager.retryTask(taskId);

      res.json({
        success: true,
        data: task,
        message: '任务重试成功'
      });
    } catch (error) {
      console.error('重试任务失败:', error);
      res.status(400).json({
        success: false,
        message: (error as Error).message || '重试任务失败'
      });
    }
  }
);

export default router;
```